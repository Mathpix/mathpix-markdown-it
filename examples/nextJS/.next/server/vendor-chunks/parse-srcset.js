"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parse-srcset";
exports.ids = ["vendor-chunks/parse-srcset"];
exports.modules = {

/***/ "(ssr)/./node_modules/parse-srcset/src/parse-srcset.js":
/*!*******************************************************!*\
  !*** ./node_modules/parse-srcset/src/parse-srcset.js ***!
  \*******************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n/**\n * Srcset Parser\n *\n * By Alex Bell |  MIT License\n *\n * JS Parser for the string value that appears in markup <img srcset=\"here\">\n *\n * @returns Array [{url: _, d: _, w: _, h:_}, ...]\n *\n * Based super duper closely on the reference algorithm at:\n * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n *\n * Most comments are copied in directly from the spec\n * (except for comments in parens).\n */ (function(root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function() {\n    // 1. Let input be the value passed to this algorithm.\n    return function(input) {\n        // UTILITY FUNCTIONS\n        // Manual is faster than RegEx\n        // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript\n        // http://jsperf.com/whitespace-character/5\n        function isSpace(c) {\n            return c === \" \" || // space\n            c === \"\t\" || // horizontal tab\n            c === \"\\n\" || // new line\n            c === \"\\f\" || // form feed\n            c === \"\\r\"; // carriage return\n        }\n        function collectCharacters(regEx) {\n            var chars, match = regEx.exec(input.substring(pos));\n            if (match) {\n                chars = match[0];\n                pos += chars.length;\n                return chars;\n            }\n        }\n        var inputLength = input.length, // (Don't use \\s, to avoid matching non-breaking space)\n        regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/, regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/, regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\\d+$/, // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n        // Must include at least one digit.\n        // According to spec tests any decimal point must be followed by a digit.\n        // No leading plus sign is allowed.)\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, // 2. Let position be a pointer into input, initially pointing at the start\n        //    of the string.\n        pos = 0, // 3. Let candidates be an initially empty source set.\n        candidates = [];\n        // 4. Splitting loop: Collect a sequence of characters that are space\n        //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n        //    were collected, that is a parse error.\n        while(true){\n            collectCharacters(regexLeadingCommasOrSpaces);\n            // 5. If position is past the end of input, return candidates and abort these steps.\n            if (pos >= inputLength) {\n                return candidates; // (we're done, this is the sole return path)\n            }\n            // 6. Collect a sequence of characters that are not space characters,\n            //    and let that be url.\n            url = collectCharacters(regexLeadingNotSpaces);\n            // 7. Let descriptors be a new empty list.\n            descriptors = [];\n            // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n            //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n            //         more than one character, that is a parse error.\n            if (url.slice(-1) === \",\") {\n                url = url.replace(regexTrailingCommas, \"\");\n                // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n                parseDescriptors();\n            //\tOtherwise, follow these substeps:\n            } else {\n                tokenize();\n            } // (close else of step 8)\n        // 16. Return to the step labeled splitting loop.\n        } // (Close of big while loop.)\n        /**\n\t\t * Tokenizes descriptor properties prior to parsing\n\t\t * Returns undefined.\n\t\t */ function tokenize() {\n            // 8.1. Descriptor tokeniser: Skip whitespace\n            collectCharacters(regexLeadingSpaces);\n            // 8.2. Let current descriptor be the empty string.\n            currentDescriptor = \"\";\n            // 8.3. Let state be in descriptor.\n            state = \"in descriptor\";\n            while(true){\n                // 8.4. Let c be the character at position.\n                c = input.charAt(pos);\n                //  Do the following depending on the value of state.\n                //  For the purpose of this step, \"EOF\" is a special character representing\n                //  that position is past the end of input.\n                // In descriptor\n                if (state === \"in descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors and let current descriptor be the empty string.\n                    // Set state to after descriptor.\n                    if (isSpace(c)) {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                            currentDescriptor = \"\";\n                            state = \"after descriptor\";\n                        }\n                    // U+002C COMMA (,)\n                    // Advance position to the next character in input. If current descriptor\n                    // is not empty, append current descriptor to descriptors. Jump to the step\n                    // labeled descriptor parser.\n                    } else if (c === \",\") {\n                        pos += 1;\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // U+0028 LEFT PARENTHESIS (()\n                    // Append c to current descriptor. Set state to in parens.\n                    } else if (c === \"(\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in parens\";\n                    // EOF\n                    // If current descriptor is not empty, append current descriptor to\n                    // descriptors. Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        if (currentDescriptor) {\n                            descriptors.push(currentDescriptor);\n                        }\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // (end \"in descriptor\"\n                // In parens\n                } else if (state === \"in parens\") {\n                    // U+0029 RIGHT PARENTHESIS ())\n                    // Append c to current descriptor. Set state to in descriptor.\n                    if (c === \")\") {\n                        currentDescriptor = currentDescriptor + c;\n                        state = \"in descriptor\";\n                    // EOF\n                    // Append current descriptor to descriptors. Jump to the step labeled\n                    // descriptor parser.\n                    } else if (c === \"\") {\n                        descriptors.push(currentDescriptor);\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Append c to current descriptor.\n                    } else {\n                        currentDescriptor = currentDescriptor + c;\n                    }\n                // After descriptor\n                } else if (state === \"after descriptor\") {\n                    // Do the following, depending on the value of c:\n                    // Space character: Stay in this state.\n                    if (isSpace(c)) {\n                    // EOF: Jump to the step labeled descriptor parser.\n                    } else if (c === \"\") {\n                        parseDescriptors();\n                        return;\n                    // Anything else\n                    // Set state to in descriptor. Set position to the previous character in input.\n                    } else {\n                        state = \"in descriptor\";\n                        pos -= 1;\n                    }\n                }\n                // Advance position to the next character in input.\n                pos += 1;\n            // Repeat this step.\n            } // (close while true loop)\n        }\n        /**\n\t\t * Adds descriptor properties to a candidate, pushes to the candidates array\n\t\t * @return undefined\n\t\t */ // Declared outside of the while loop so that it's only created once.\n        function parseDescriptors() {\n            // 9. Descriptor parser: Let error be no.\n            var pError = false, // 10. Let width be absent.\n            // 11. Let density be absent.\n            // 12. Let future-compat-h be absent. (We're implementing it now as h)\n            w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;\n            // 13. For each descriptor in descriptors, run the appropriate set of steps\n            // from the following list:\n            for(i = 0; i < descriptors.length; i++){\n                desc = descriptors[i];\n                lastChar = desc[desc.length - 1];\n                value = desc.substring(0, desc.length - 1);\n                intVal = parseInt(value, 10);\n                floatVal = parseFloat(value);\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0077 LATIN SMALL LETTER W character\n                if (regexNonNegativeInteger.test(value) && lastChar === \"w\") {\n                    // If width and density are not both absent, then let error be yes.\n                    if (w || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes.\n                    // Otherwise, let width be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        w = intVal;\n                    }\n                // If the descriptor consists of a valid floating-point number followed by\n                // a U+0078 LATIN SMALL LETTER X character\n                } else if (regexFloatingPoint.test(value) && lastChar === \"x\") {\n                    // If width, density and future-compat-h are not all absent, then let error\n                    // be yes.\n                    if (w || d || h) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing floating-point number values to the descriptor.\n                    // If the result is less than zero, let error be yes. Otherwise, let density\n                    // be the result.\n                    if (floatVal < 0) {\n                        pError = true;\n                    } else {\n                        d = floatVal;\n                    }\n                // If the descriptor consists of a valid non-negative integer followed by\n                // a U+0068 LATIN SMALL LETTER H character\n                } else if (regexNonNegativeInteger.test(value) && lastChar === \"h\") {\n                    // If height and density are not both absent, then let error be yes.\n                    if (h || d) {\n                        pError = true;\n                    }\n                    // Apply the rules for parsing non-negative integers to the descriptor.\n                    // If the result is zero, let error be yes. Otherwise, let future-compat-h\n                    // be the result.\n                    if (intVal === 0) {\n                        pError = true;\n                    } else {\n                        h = intVal;\n                    }\n                // Anything else, Let error be yes.\n                } else {\n                    pError = true;\n                }\n            } // (close step 13 for loop)\n            // 15. If error is still no, then append a new image source to candidates whose\n            // URL is url, associated with a width width if not absent and a pixel\n            // density density if not absent. Otherwise, there is a parse error.\n            if (!pError) {\n                candidate.url = url;\n                if (w) {\n                    candidate.w = w;\n                }\n                if (d) {\n                    candidate.d = d;\n                }\n                if (h) {\n                    candidate.h = h;\n                }\n                candidates.push(candidate);\n            } else if (console && console.log) {\n                console.log(\"Invalid srcset descriptor found in '\" + input + \"' at '\" + desc + \"'.\");\n            }\n        } // (close parseDescriptors fn)\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFyc2Utc3Jjc2V0L3NyYy9wYXJzZS1zcmNzZXQuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBRUEsVUFBVUEsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZCLElBQUksSUFBMEMsRUFBRTtRQUMvQyx3Q0FBd0M7UUFDeENDLGlDQUFPLEVBQUUsb0NBQUVELE9BQU9BO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUNwQixPQUFPLEVBUU47QUFDRixHQUFFLFFBQU07SUFFUCxzREFBc0Q7SUFDdEQsT0FBTyxTQUFVTSxLQUFLO1FBRXJCLG9CQUFvQjtRQUVwQiw4QkFBOEI7UUFDOUIsdUVBQXVFO1FBQ3ZFLDJDQUEyQztRQUMzQyxTQUFTQyxRQUFRQyxDQUFDO1lBQ2pCLE9BQVFBLE1BQU0sT0FBWSxRQUFRO1lBQ2xDQSxNQUFNLE9BQVksaUJBQWlCO1lBQ25DQSxNQUFNLFFBQVksV0FBVztZQUM3QkEsTUFBTSxRQUFZLFlBQVk7WUFDOUJBLE1BQU0sTUFBWSxrQkFBa0I7UUFDckM7UUFFQSxTQUFTQyxrQkFBa0JDLEtBQUs7WUFDL0IsSUFBSUMsT0FDSEMsUUFBUUYsTUFBTUcsSUFBSSxDQUFDUCxNQUFNUSxTQUFTLENBQUNDO1lBQ3BDLElBQUlILE9BQU87Z0JBQ1ZELFFBQVFDLEtBQUssQ0FBRSxFQUFHO2dCQUNsQkcsT0FBT0osTUFBTUssTUFBTTtnQkFDbkIsT0FBT0w7WUFDUjtRQUNEO1FBRUEsSUFBSU0sY0FBY1gsTUFBTVUsTUFBTSxFQUU3Qix1REFBdUQ7UUFDdkRFLHFCQUFxQixxQkFDckJDLDZCQUE2QixzQkFDN0JDLHdCQUF3QixzQkFDeEJDLHNCQUFzQixTQUN0QkMsMEJBQTBCLFNBRTFCLHlGQUF5RjtRQUN6RixtQ0FBbUM7UUFDbkMseUVBQXlFO1FBQ3pFLG9DQUFvQztRQUNwQyx5RkFBeUY7UUFDekZDLHFCQUFxQixxREFFckJDLEtBQ0FDLGFBQ0FDLG1CQUNBQyxPQUNBbkIsR0FFQSwy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QztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3BhcnNlLXNyY3NldC9zcmMvcGFyc2Utc3Jjc2V0LmpzP2VmODAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTcmNzZXQgUGFyc2VyXG4gKlxuICogQnkgQWxleCBCZWxsIHwgIE1JVCBMaWNlbnNlXG4gKlxuICogSlMgUGFyc2VyIGZvciB0aGUgc3RyaW5nIHZhbHVlIHRoYXQgYXBwZWFycyBpbiBtYXJrdXAgPGltZyBzcmNzZXQ9XCJoZXJlXCI+XG4gKlxuICogQHJldHVybnMgQXJyYXkgW3t1cmw6IF8sIGQ6IF8sIHc6IF8sIGg6X30sIC4uLl1cbiAqXG4gKiBCYXNlZCBzdXBlciBkdXBlciBjbG9zZWx5IG9uIHRoZSByZWZlcmVuY2UgYWxnb3JpdGhtIGF0OlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3BhcnNlLWEtc3Jjc2V0LWF0dHJpYnV0ZVxuICpcbiAqIE1vc3QgY29tbWVudHMgYXJlIGNvcGllZCBpbiBkaXJlY3RseSBmcm9tIHRoZSBzcGVjXG4gKiAoZXhjZXB0IGZvciBjb21tZW50cyBpbiBwYXJlbnMpLlxuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHQvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcblx0XHQvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcblx0XHQvLyBsaWtlIE5vZGUuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcblx0XHRyb290LnBhcnNlU3Jjc2V0ID0gZmFjdG9yeSgpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuXHQvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGlzIGFsZ29yaXRobS5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbnB1dCkge1xuXG5cdFx0Ly8gVVRJTElUWSBGVU5DVElPTlNcblxuXHRcdC8vIE1hbnVhbCBpcyBmYXN0ZXIgdGhhbiBSZWdFeFxuXHRcdC8vIGh0dHA6Ly9iam9ybi50aXBsaW5nLmNvbS9zdGF0ZS1hbmQtcmVndWxhci1leHByZXNzaW9ucy1pbi1qYXZhc2NyaXB0XG5cdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vd2hpdGVzcGFjZS1jaGFyYWN0ZXIvNVxuXHRcdGZ1bmN0aW9uIGlzU3BhY2UoYykge1xuXHRcdFx0cmV0dXJuIChjID09PSBcIlxcdTAwMjBcIiB8fCAvLyBzcGFjZVxuXHRcdFx0YyA9PT0gXCJcXHUwMDA5XCIgfHwgLy8gaG9yaXpvbnRhbCB0YWJcblx0XHRcdGMgPT09IFwiXFx1MDAwQVwiIHx8IC8vIG5ldyBsaW5lXG5cdFx0XHRjID09PSBcIlxcdTAwMENcIiB8fCAvLyBmb3JtIGZlZWRcblx0XHRcdGMgPT09IFwiXFx1MDAwRFwiKTsgIC8vIGNhcnJpYWdlIHJldHVyblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XG5cdFx0XHR2YXIgY2hhcnMsXG5cdFx0XHRcdG1hdGNoID0gcmVnRXguZXhlYyhpbnB1dC5zdWJzdHJpbmcocG9zKSk7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y2hhcnMgPSBtYXRjaFsgMCBdO1xuXHRcdFx0XHRwb3MgKz0gY2hhcnMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gY2hhcnM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXG5cdFx0XHQvLyAoRG9uJ3QgdXNlIFxccywgdG8gYXZvaWQgbWF0Y2hpbmcgbm9uLWJyZWFraW5nIHNwYWNlKVxuXHRcdFx0cmVnZXhMZWFkaW5nU3BhY2VzID0gL15bIFxcdFxcblxcclxcdTAwMGNdKy8sXG5cdFx0XHRyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0XHRcdHJlZ2V4TGVhZGluZ05vdFNwYWNlcyA9IC9eW14gXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0XHRcdHJlZ2V4VHJhaWxpbmdDb21tYXMgPSAvWyxdKyQvLFxuXHRcdFx0cmVnZXhOb25OZWdhdGl2ZUludGVnZXIgPSAvXlxcZCskLyxcblxuXHRcdFx0Ly8gKCBQb3NpdGl2ZSBvciBuZWdhdGl2ZSBvciB1bnNpZ25lZCBpbnRlZ2VycyBvciBkZWNpbWFscywgd2l0aG91dCBvciB3aXRob3V0IGV4cG9uZW50cy5cblx0XHRcdC8vIE11c3QgaW5jbHVkZSBhdCBsZWFzdCBvbmUgZGlnaXQuXG5cdFx0XHQvLyBBY2NvcmRpbmcgdG8gc3BlYyB0ZXN0cyBhbnkgZGVjaW1hbCBwb2ludCBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgZGlnaXQuXG5cdFx0XHQvLyBObyBsZWFkaW5nIHBsdXMgc2lnbiBpcyBhbGxvd2VkLilcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjdmFsaWQtZmxvYXRpbmctcG9pbnQtbnVtYmVyXG5cdFx0XHRyZWdleEZsb2F0aW5nUG9pbnQgPSAvXi0/KD86WzAtOV0rfFswLTldKlxcLlswLTldKykoPzpbZUVdWystXT9bMC05XSspPyQvLFxuXG5cdFx0XHR1cmwsXG5cdFx0XHRkZXNjcmlwdG9ycyxcblx0XHRcdGN1cnJlbnREZXNjcmlwdG9yLFxuXHRcdFx0c3RhdGUsXG5cdFx0XHRjLFxuXG5cdFx0XHQvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb2ludGVyIGludG8gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnRcblx0XHRcdC8vICAgIG9mIHRoZSBzdHJpbmcuXG5cdFx0XHRwb3MgPSAwLFxuXG5cdFx0XHQvLyAzLiBMZXQgY2FuZGlkYXRlcyBiZSBhbiBpbml0aWFsbHkgZW1wdHkgc291cmNlIHNldC5cblx0XHRcdGNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdC8vIDQuIFNwbGl0dGluZyBsb29wOiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBzcGFjZVxuXHRcdC8vICAgIGNoYXJhY3RlcnMgb3IgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMuIElmIGFueSBVKzAwMkMgQ09NTUEgY2hhcmFjdGVyc1xuXHRcdC8vICAgIHdlcmUgY29sbGVjdGVkLCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzKTtcblxuXHRcdFx0Ly8gNS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCByZXR1cm4gY2FuZGlkYXRlcyBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG5cdFx0XHRpZiAocG9zID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBjYW5kaWRhdGVzOyAvLyAod2UncmUgZG9uZSwgdGhpcyBpcyB0aGUgc29sZSByZXR1cm4gcGF0aClcblx0XHRcdH1cblxuXHRcdFx0Ly8gNi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IHNwYWNlIGNoYXJhY3RlcnMsXG5cdFx0XHQvLyAgICBhbmQgbGV0IHRoYXQgYmUgdXJsLlxuXHRcdFx0dXJsID0gY29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nTm90U3BhY2VzKTtcblxuXHRcdFx0Ly8gNy4gTGV0IGRlc2NyaXB0b3JzIGJlIGEgbmV3IGVtcHR5IGxpc3QuXG5cdFx0XHRkZXNjcmlwdG9ycyA9IFtdO1xuXG5cdFx0XHQvLyA4LiBJZiB1cmwgZW5kcyB3aXRoIGEgVSswMDJDIENPTU1BIGNoYXJhY3RlciAoLCksIGZvbGxvdyB0aGVzZSBzdWJzdGVwczpcblx0XHRcdC8vXHRcdCgxKS4gUmVtb3ZlIGFsbCB0cmFpbGluZyBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycyBmcm9tIHVybC4gSWYgdGhpcyByZW1vdmVkXG5cdFx0XHQvLyAgICAgICAgIG1vcmUgdGhhbiBvbmUgY2hhcmFjdGVyLCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG5cdFx0XHRpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcblx0XHRcdFx0dXJsID0gdXJsLnJlcGxhY2UocmVnZXhUcmFpbGluZ0NvbW1hcywgXCJcIik7XG5cdFx0XHRcdC8vIChKdW1wIGFoZWFkIHRvIHN0ZXAgOSB0byBza2lwIHRva2VuaXphdGlvbiBhbmQganVzdCBwdXNoIHRoZSBjYW5kaWRhdGUpLlxuXHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cblx0XHRcdFx0Ly9cdE90aGVyd2lzZSwgZm9sbG93IHRoZXNlIHN1YnN0ZXBzOlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9rZW5pemUoKTtcblx0XHRcdH0gLy8gKGNsb3NlIGVsc2Ugb2Ygc3RlcCA4KVxuXG5cdFx0XHQvLyAxNi4gUmV0dXJuIHRvIHRoZSBzdGVwIGxhYmVsZWQgc3BsaXR0aW5nIGxvb3AuXG5cdFx0fSAvLyAoQ2xvc2Ugb2YgYmlnIHdoaWxlIGxvb3AuKVxuXG5cdFx0LyoqXG5cdFx0ICogVG9rZW5pemVzIGRlc2NyaXB0b3IgcHJvcGVydGllcyBwcmlvciB0byBwYXJzaW5nXG5cdFx0ICogUmV0dXJucyB1bmRlZmluZWQuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdG9rZW5pemUoKSB7XG5cblx0XHRcdC8vIDguMS4gRGVzY3JpcHRvciB0b2tlbmlzZXI6IFNraXAgd2hpdGVzcGFjZVxuXHRcdFx0Y29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nU3BhY2VzKTtcblxuXHRcdFx0Ly8gOC4yLiBMZXQgY3VycmVudCBkZXNjcmlwdG9yIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cblx0XHRcdC8vIDguMy4gTGV0IHN0YXRlIGJlIGluIGRlc2NyaXB0b3IuXG5cdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0XHRcdC8vIDguNC4gTGV0IGMgYmUgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbi5cblx0XHRcdFx0YyA9IGlucHV0LmNoYXJBdChwb3MpO1xuXG5cdFx0XHRcdC8vICBEbyB0aGUgZm9sbG93aW5nIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Ygc3RhdGUuXG5cdFx0XHRcdC8vICBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBzdGVwLCBcIkVPRlwiIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nXG5cdFx0XHRcdC8vICB0aGF0IHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dC5cblxuXHRcdFx0XHQvLyBJbiBkZXNjcmlwdG9yXG5cdFx0XHRcdGlmIChzdGF0ZSA9PT0gXCJpbiBkZXNjcmlwdG9yXCIpIHtcblx0XHRcdFx0XHQvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cblx0XHRcdFx0XHQvLyBTcGFjZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHQvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdFx0Ly8gZGVzY3JpcHRvcnMgYW5kIGxldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0XHRcdFx0XHQvLyBTZXQgc3RhdGUgdG8gYWZ0ZXIgZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoaXNTcGFjZShjKSkge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gXCJhZnRlciBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFUrMDAyQyBDT01NQSAoLClcblx0XHRcdFx0XHRcdC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LiBJZiBjdXJyZW50IGRlc2NyaXB0b3Jcblx0XHRcdFx0XHRcdC8vIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcFxuXHRcdFx0XHRcdFx0Ly8gbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiLFwiKSB7XG5cdFx0XHRcdFx0XHRwb3MgKz0gMTtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0Ly8gVSswMDI4IExFRlQgUEFSRU5USEVTSVMgKCgpXG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuIFNldCBzdGF0ZSB0byBpbiBwYXJlbnMuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlxcdTAwMjhcIikge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gcGFyZW5zXCI7XG5cblx0XHRcdFx0XHRcdC8vIEVPRlxuXHRcdFx0XHRcdFx0Ly8gSWYgY3VycmVudCBkZXNjcmlwdG9yIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0b1xuXHRcdFx0XHRcdFx0Ly8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZVxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gKGVuZCBcImluIGRlc2NyaXB0b3JcIlxuXG5cdFx0XHRcdFx0Ly8gSW4gcGFyZW5zXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09IFwiaW4gcGFyZW5zXCIpIHtcblxuXHRcdFx0XHRcdC8vIFUrMDAyOSBSSUdIVCBQQVJFTlRIRVNJUyAoKSlcblx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuIFNldCBzdGF0ZSB0byBpbiBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdGlmIChjID09PSBcIilcIikge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXG5cdFx0XHRcdFx0XHQvLyBFT0Zcblx0XHRcdFx0XHRcdC8vIEFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZFxuXHRcdFx0XHRcdFx0Ly8gZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZVxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBZnRlciBkZXNjcmlwdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RhdGUgPT09IFwiYWZ0ZXIgZGVzY3JpcHRvclwiKSB7XG5cblx0XHRcdFx0XHQvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cdFx0XHRcdFx0Ly8gU3BhY2UgY2hhcmFjdGVyOiBTdGF5IGluIHRoaXMgc3RhdGUuXG5cdFx0XHRcdFx0aWYgKGlzU3BhY2UoYykpIHtcblxuXHRcdFx0XHRcdFx0Ly8gRU9GOiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHRcdC8vIFNldCBzdGF0ZSB0byBpbiBkZXNjcmlwdG9yLiBTZXQgcG9zaXRpb24gdG8gdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpbiBpbnB1dC5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblx0XHRcdFx0XHRcdHBvcyAtPSAxO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWR2YW5jZSBwb3NpdGlvbiB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gaW5wdXQuXG5cdFx0XHRcdHBvcyArPSAxO1xuXG5cdFx0XHRcdC8vIFJlcGVhdCB0aGlzIHN0ZXAuXG5cdFx0XHR9IC8vIChjbG9zZSB3aGlsZSB0cnVlIGxvb3ApXG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBkZXNjcmlwdG9yIHByb3BlcnRpZXMgdG8gYSBjYW5kaWRhdGUsIHB1c2hlcyB0byB0aGUgY2FuZGlkYXRlcyBhcnJheVxuXHRcdCAqIEByZXR1cm4gdW5kZWZpbmVkXG5cdFx0ICovXG5cdFx0Ly8gRGVjbGFyZWQgb3V0c2lkZSBvZiB0aGUgd2hpbGUgbG9vcCBzbyB0aGF0IGl0J3Mgb25seSBjcmVhdGVkIG9uY2UuXG5cdFx0ZnVuY3Rpb24gcGFyc2VEZXNjcmlwdG9ycygpIHtcblxuXHRcdFx0Ly8gOS4gRGVzY3JpcHRvciBwYXJzZXI6IExldCBlcnJvciBiZSBuby5cblx0XHRcdHZhciBwRXJyb3IgPSBmYWxzZSxcblxuXHRcdFx0XHQvLyAxMC4gTGV0IHdpZHRoIGJlIGFic2VudC5cblx0XHRcdFx0Ly8gMTEuIExldCBkZW5zaXR5IGJlIGFic2VudC5cblx0XHRcdFx0Ly8gMTIuIExldCBmdXR1cmUtY29tcGF0LWggYmUgYWJzZW50LiAoV2UncmUgaW1wbGVtZW50aW5nIGl0IG5vdyBhcyBoKVxuXHRcdFx0XHR3LCBkLCBoLCBpLFxuXHRcdFx0XHRjYW5kaWRhdGUgPSB7fSxcblx0XHRcdFx0ZGVzYywgbGFzdENoYXIsIHZhbHVlLCBpbnRWYWwsIGZsb2F0VmFsO1xuXG5cdFx0XHQvLyAxMy4gRm9yIGVhY2ggZGVzY3JpcHRvciBpbiBkZXNjcmlwdG9ycywgcnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHNcblx0XHRcdC8vIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuXHRcdFx0Zm9yIChpID0gMCA7IGkgPCBkZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXNjID0gZGVzY3JpcHRvcnNbIGkgXTtcblxuXHRcdFx0XHRsYXN0Q2hhciA9IGRlc2NbIGRlc2MubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHR2YWx1ZSA9IGRlc2Muc3Vic3RyaW5nKDAsIGRlc2MubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdGludFZhbCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdFx0XHRcdGZsb2F0VmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuXHRcdFx0XHQvLyBhIFUrMDA3NyBMQVRJTiBTTUFMTCBMRVRURVIgVyBjaGFyYWN0ZXJcblx0XHRcdFx0aWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJ3XCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3aWR0aCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKHcgfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBsZXQgd2lkdGggYmUgdGhlIHJlc3VsdC5cblx0XHRcdFx0XHRpZiAoaW50VmFsID09PSAwKSB7cEVycm9yID0gdHJ1ZTt9IGVsc2Uge3cgPSBpbnRWYWw7fVxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9sbG93ZWQgYnlcblx0XHRcdFx0XHQvLyBhIFUrMDA3OCBMQVRJTiBTTUFMTCBMRVRURVIgWCBjaGFyYWN0ZXJcblx0XHRcdFx0fSBlbHNlIGlmIChyZWdleEZsb2F0aW5nUG9pbnQudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcInhcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIHdpZHRoLCBkZW5zaXR5IGFuZCBmdXR1cmUtY29tcGF0LWggYXJlIG5vdCBhbGwgYWJzZW50LCB0aGVuIGxldCBlcnJvclxuXHRcdFx0XHRcdC8vIGJlIHllcy5cblx0XHRcdFx0XHRpZiAodyB8fCBkIHx8IGgpIHtwRXJyb3IgPSB0cnVlO31cblxuXHRcdFx0XHRcdC8vIEFwcGx5IHRoZSBydWxlcyBmb3IgcGFyc2luZyBmbG9hdGluZy1wb2ludCBudW1iZXIgdmFsdWVzIHRvIHRoZSBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdC8vIElmIHRoZSByZXN1bHQgaXMgbGVzcyB0aGFuIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuIE90aGVyd2lzZSwgbGV0IGRlbnNpdHlcblx0XHRcdFx0XHQvLyBiZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRcdGlmIChmbG9hdFZhbCA8IDApIHtwRXJyb3IgPSB0cnVlO30gZWxzZSB7ZCA9IGZsb2F0VmFsO31cblxuXHRcdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgbm9uLW5lZ2F0aXZlIGludGVnZXIgZm9sbG93ZWQgYnlcblx0XHRcdFx0XHQvLyBhIFUrMDA2OCBMQVRJTiBTTUFMTCBMRVRURVIgSCBjaGFyYWN0ZXJcblx0XHRcdFx0fSBlbHNlIGlmIChyZWdleE5vbk5lZ2F0aXZlSW50ZWdlci50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwiaFwiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgaGVpZ2h0IGFuZCBkZW5zaXR5IGFyZSBub3QgYm90aCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0XHRpZiAoaCB8fCBkKSB7cEVycm9yID0gdHJ1ZTt9XG5cblx0XHRcdFx0XHQvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgbm9uLW5lZ2F0aXZlIGludGVnZXJzIHRvIHRoZSBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZnV0dXJlLWNvbXBhdC1oXG5cdFx0XHRcdFx0Ly8gYmUgdGhlIHJlc3VsdC5cblx0XHRcdFx0XHRpZiAoaW50VmFsID09PSAwKSB7cEVycm9yID0gdHJ1ZTt9IGVsc2Uge2ggPSBpbnRWYWw7fVxuXG5cdFx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSwgTGV0IGVycm9yIGJlIHllcy5cblx0XHRcdFx0fSBlbHNlIHtwRXJyb3IgPSB0cnVlO31cblx0XHRcdH0gLy8gKGNsb3NlIHN0ZXAgMTMgZm9yIGxvb3ApXG5cblx0XHRcdC8vIDE1LiBJZiBlcnJvciBpcyBzdGlsbCBubywgdGhlbiBhcHBlbmQgYSBuZXcgaW1hZ2Ugc291cmNlIHRvIGNhbmRpZGF0ZXMgd2hvc2Vcblx0XHRcdC8vIFVSTCBpcyB1cmwsIGFzc29jaWF0ZWQgd2l0aCBhIHdpZHRoIHdpZHRoIGlmIG5vdCBhYnNlbnQgYW5kIGEgcGl4ZWxcblx0XHRcdC8vIGRlbnNpdHkgZGVuc2l0eSBpZiBub3QgYWJzZW50LiBPdGhlcndpc2UsIHRoZXJlIGlzIGEgcGFyc2UgZXJyb3IuXG5cdFx0XHRpZiAoIXBFcnJvcikge1xuXHRcdFx0XHRjYW5kaWRhdGUudXJsID0gdXJsO1xuXHRcdFx0XHRpZiAodykgeyBjYW5kaWRhdGUudyA9IHc7fVxuXHRcdFx0XHRpZiAoZCkgeyBjYW5kaWRhdGUuZCA9IGQ7fVxuXHRcdFx0XHRpZiAoaCkgeyBjYW5kaWRhdGUuaCA9IGg7fVxuXHRcdFx0XHRjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkludmFsaWQgc3Jjc2V0IGRlc2NyaXB0b3IgZm91bmQgaW4gJ1wiICtcblx0XHRcdFx0XHRpbnB1dCArIFwiJyBhdCAnXCIgKyBkZXNjICsgXCInLlwiKTtcblx0XHRcdH1cblx0XHR9IC8vIChjbG9zZSBwYXJzZURlc2NyaXB0b3JzIGZuKVxuXG5cdH1cbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXJzZVNyY3NldCIsImlucHV0IiwiaXNTcGFjZSIsImMiLCJjb2xsZWN0Q2hhcmFjdGVycyIsInJlZ0V4IiwiY2hhcnMiLCJtYXRjaCIsImV4ZWMiLCJzdWJzdHJpbmciLCJwb3MiLCJsZW5ndGgiLCJpbnB1dExlbmd0aCIsInJlZ2V4TGVhZGluZ1NwYWNlcyIsInJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzIiwicmVnZXhMZWFkaW5nTm90U3BhY2VzIiwicmVnZXhUcmFpbGluZ0NvbW1hcyIsInJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyIiwicmVnZXhGbG9hdGluZ1BvaW50IiwidXJsIiwiZGVzY3JpcHRvcnMiLCJjdXJyZW50RGVzY3JpcHRvciIsInN0YXRlIiwiY2FuZGlkYXRlcyIsInNsaWNlIiwicmVwbGFjZSIsInBhcnNlRGVzY3JpcHRvcnMiLCJ0b2tlbml6ZSIsImNoYXJBdCIsInB1c2giLCJwRXJyb3IiLCJ3IiwiZCIsImgiLCJpIiwiY2FuZGlkYXRlIiwiZGVzYyIsImxhc3RDaGFyIiwidmFsdWUiLCJpbnRWYWwiLCJmbG9hdFZhbCIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsInRlc3QiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/parse-srcset/src/parse-srcset.js\n");

/***/ })

};
;