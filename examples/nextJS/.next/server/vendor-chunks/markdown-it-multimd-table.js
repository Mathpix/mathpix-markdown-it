"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/markdown-it-multimd-table";
exports.ids = ["vendor-chunks/markdown-it-multimd-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/markdown-it-multimd-table/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it-multimd-table/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar DFA = __webpack_require__(/*! ./lib/dfa.js */ \"(ssr)/./node_modules/markdown-it-multimd-table/lib/dfa.js\");\nmodule.exports = function multimd_table_plugin(md, options) {\n    var defaults = {\n        multiline: false,\n        rowspan: false,\n        headerless: false,\n        multibody: true,\n        autolabel: true\n    };\n    options = md.utils.assign({}, defaults, options || {});\n    function scan_bound_indices(state, line) {\n        /**\n     * Naming convention of positional variables\n     * - list-item\n     * ·········longtext······\\n\n     *   ^head  ^start  ^end  ^max\n     */ var start = state.bMarks[line] + state.sCount[line], head = state.bMarks[line] + state.blkIndent, end = state.skipSpacesBack(state.eMarks[line], head), bounds = [], pos, posjump, escape = false, code = false, serial = 0;\n        /* Scan for valid pipe character position */ for(pos = start; pos < end; pos++){\n            switch(state.src.charCodeAt(pos)){\n                case 0x5c /* \\ */ :\n                    escape = true;\n                    break;\n                case 0x60 /* ` */ :\n                    posjump = state.skipChars(pos, 0x60) - 1;\n                    /* make \\` closes the code sequence, but not open it;\n             the reason is that `\\` is correct code block */ /* eslint-disable-next-line brace-style */ if (posjump > pos) {\n                        if (!code) {\n                            if (serial === 0) {\n                                serial = posjump - pos;\n                            } else if (serial === posjump - pos) {\n                                serial = 0;\n                            }\n                        }\n                        pos = posjump;\n                    } else if (code || !escape && !serial) {\n                        code = !code;\n                    }\n                    escape = false;\n                    break;\n                case 0x7c /* | */ :\n                    if (!code && !escape) {\n                        bounds.push(pos);\n                    }\n                    escape = false;\n                    break;\n                default:\n                    escape = false;\n                    break;\n            }\n        }\n        if (bounds.length === 0) return bounds;\n        /* Pad in newline characters on last and this line */ if (bounds[0] > head) {\n            bounds.unshift(head - 1);\n        }\n        if (bounds[bounds.length - 1] < end - 1) {\n            bounds.push(end);\n        }\n        return bounds;\n    }\n    function table_caption(state, silent, line) {\n        var meta = {\n            text: null,\n            label: null\n        }, start = state.bMarks[line] + state.sCount[line], max = state.eMarks[line], /* A non-greedy qualifier allows the label to be matched */ capRE = /^\\[(.+?)\\](\\[([^\\[\\]]+)\\])?\\s*$/, matches = state.src.slice(start, max).match(capRE);\n        if (!matches) {\n            return false;\n        }\n        if (silent) {\n            return true;\n        }\n        meta.text = matches[1];\n        if (!options.autolabel && !matches[2]) {\n            return meta;\n        }\n        meta.label = matches[2] || matches[1];\n        meta.label = meta.label.toLowerCase().replace(/\\W+/g, \"\");\n        return meta;\n    }\n    function table_row(state, silent, line) {\n        var meta = {\n            bounds: null,\n            multiline: null\n        }, bounds = scan_bound_indices(state, line), start, pos, oldMax;\n        if (bounds.length < 2) {\n            return false;\n        }\n        if (silent) {\n            return true;\n        }\n        meta.bounds = bounds;\n        /* Multiline. Scan boundaries again since it's very complicated */ if (options.multiline) {\n            start = state.bMarks[line] + state.sCount[line];\n            pos = state.eMarks[line] - 1; /* where backslash should be */ \n            meta.multiline = state.src.charCodeAt(pos) === 0x5C /* \\ */ ;\n            if (meta.multiline) {\n                oldMax = state.eMarks[line];\n                state.eMarks[line] = state.skipSpacesBack(pos, start);\n                meta.bounds = scan_bound_indices(state, line);\n                state.eMarks[line] = oldMax;\n            }\n        }\n        return meta;\n    }\n    function table_separator(state, silent, line) {\n        var meta = {\n            aligns: [],\n            wraps: []\n        }, bounds = scan_bound_indices(state, line), sepRE = /^:?(-+|=+):?\\+?$/, c, text, align;\n        /* Only separator needs to check indents */ if (state.sCount[line] - state.blkIndent >= 4) {\n            return false;\n        }\n        if (bounds.length === 0) {\n            return false;\n        }\n        for(c = 0; c < bounds.length - 1; c++){\n            text = state.src.slice(bounds[c] + 1, bounds[c + 1]).trim();\n            if (!sepRE.test(text)) {\n                return false;\n            }\n            meta.wraps.push(text.charCodeAt(text.length - 1) === 0x2B /* + */ );\n            align = (text.charCodeAt(0) === 0x3A /* : */ ) << 4 | text.charCodeAt(text.length - 1 - meta.wraps[c]) === 0x3A;\n            switch(align){\n                case 0x00:\n                    meta.aligns.push(\"\");\n                    break;\n                case 0x01:\n                    meta.aligns.push(\"right\");\n                    break;\n                case 0x10:\n                    meta.aligns.push(\"left\");\n                    break;\n                case 0x11:\n                    meta.aligns.push(\"center\");\n                    break;\n            }\n        }\n        if (silent) {\n            return true;\n        }\n        return meta;\n    }\n    function table_empty(state, silent, line) {\n        return state.isEmpty(line);\n    }\n    function table(state, startLine, endLine, silent) {\n        /**\n     * Regex pseudo code for table:\n     *     caption? header+ separator (data+ empty)* data+ caption?\n     *\n     * We use DFA to emulate this plugin. Types with lower precedence are\n     * set-minus from all the formers.  Noted that separator should have higher\n     * precedence than header or data.\n     *   |  state  | caption separator header data empty | --> lower precedence\n     *   | 0x10100 |    1        0       1     0     0   |\n     */ var tableDFA = new DFA(), grp = 0x10, mtr = -1, token, tableToken, trToken, colspan, leftToken, rowspan, upTokens = [], tableLines, tgroupLines, tag, text, range, r, c, b, t, blockState;\n        if (startLine + 2 > endLine) {\n            return false;\n        }\n        /**\n     * First pass: validate and collect info into table token. IR is stored in\n     * markdown-it `token.meta` to be pushed later. table/tr open tokens are\n     * generated here.\n     */ tableToken = new state.Token(\"table_open\", \"table\", 1);\n        tableToken.meta = {\n            sep: null,\n            cap: null,\n            tr: []\n        };\n        tableDFA.set_highest_alphabet(0x10000);\n        tableDFA.set_initial_state(0x10100);\n        tableDFA.set_accept_states([\n            0x10010,\n            0x10011,\n            0x00000\n        ]);\n        tableDFA.set_match_alphabets({\n            0x10000: table_caption.bind(this, state, true),\n            0x01000: table_separator.bind(this, state, true),\n            0x00100: table_row.bind(this, state, true),\n            0x00010: table_row.bind(this, state, true),\n            0x00001: table_empty.bind(this, state, true)\n        });\n        tableDFA.set_transitions({\n            0x10100: {\n                0x10000: 0x00100,\n                0x00100: 0x01100\n            },\n            0x00100: {\n                0x00100: 0x01100\n            },\n            0x01100: {\n                0x01000: 0x10010,\n                0x00100: 0x01100\n            },\n            0x10010: {\n                0x10000: 0x00000,\n                0x00010: 0x10011\n            },\n            0x10011: {\n                0x10000: 0x00000,\n                0x00010: 0x10011,\n                0x00001: 0x10010\n            }\n        });\n        if (options.headerless) {\n            tableDFA.set_initial_state(0x11100);\n            tableDFA.update_transition(0x11100, {\n                0x10000: 0x01100,\n                0x01000: 0x10010,\n                0x00100: 0x01100\n            });\n            trToken = new state.Token(\"tr_placeholder\", \"tr\", 0);\n            trToken.meta = Object(); // avoid trToken.meta.grp throws exception\n        }\n        if (!options.multibody) {\n            tableDFA.update_transition(0x10010, {\n                0x10000: 0x00000,\n                0x00010: 0x10010\n            } // 0x10011 is never reached\n            );\n        }\n        /* Don't mix up DFA `_state` and markdown-it `state` */ tableDFA.set_actions(function(_line, _state, _type) {\n            // console.log(_line, _state.toString(16), _type.toString(16))  // for test\n            switch(_type){\n                case 0x10000:\n                    if (tableToken.meta.cap) {\n                        break;\n                    }\n                    tableToken.meta.cap = table_caption(state, false, _line);\n                    tableToken.meta.cap.map = [\n                        _line,\n                        _line + 1\n                    ];\n                    tableToken.meta.cap.first = _line === startLine;\n                    break;\n                case 0x01000:\n                    tableToken.meta.sep = table_separator(state, false, _line);\n                    tableToken.meta.sep.map = [\n                        _line,\n                        _line + 1\n                    ];\n                    trToken.meta.grp |= 0x01; // previously assigned at case 0x00110\n                    grp = 0x10;\n                    break;\n                case 0x00100:\n                case 0x00010:\n                    trToken = new state.Token(\"tr_open\", \"tr\", 1);\n                    trToken.map = [\n                        _line,\n                        _line + 1\n                    ];\n                    trToken.meta = table_row(state, false, _line);\n                    trToken.meta.type = _type;\n                    trToken.meta.grp = grp;\n                    grp = 0x00;\n                    tableToken.meta.tr.push(trToken);\n                    /* Multiline. Merge trTokens as an entire multiline trToken */ if (options.multiline) {\n                        if (trToken.meta.multiline && mtr < 0) {\n                            /* Start line of multiline row. mark this trToken */ mtr = tableToken.meta.tr.length - 1;\n                        } else if (!trToken.meta.multiline && mtr >= 0) {\n                            /* End line of multiline row. merge forward until the marked trToken */ token = tableToken.meta.tr[mtr];\n                            token.meta.mbounds = tableToken.meta.tr.slice(mtr).map(function(tk) {\n                                return tk.meta.bounds;\n                            });\n                            token.map[1] = trToken.map[1];\n                            tableToken.meta.tr = tableToken.meta.tr.slice(0, mtr + 1);\n                            mtr = -1;\n                        }\n                    }\n                    break;\n                case 0x00001:\n                    trToken.meta.grp |= 0x01;\n                    grp = 0x10;\n                    break;\n            }\n        });\n        if (tableDFA.execute(startLine, endLine) === false) {\n            return false;\n        }\n        // if (!tableToken.meta.sep) { return false; } // always evaluated true\n        if (!tableToken.meta.tr.length) {\n            return false;\n        } // false under headerless corner case\n        if (silent) {\n            return true;\n        }\n        /* Last data row cannot be detected. not stored to trToken outside? */ tableToken.meta.tr[tableToken.meta.tr.length - 1].meta.grp |= 0x01;\n        /**\n     * Second pass: actually push the tokens into `state.tokens`.\n     * thead/tbody/th/td open tokens and all closed tokens are generated here;\n     * thead/tbody are generally called tgroup; td/th are generally called tcol.\n     */ tableToken.map = tableLines = [\n            startLine,\n            0\n        ];\n        tableToken.block = true;\n        tableToken.level = state.level++;\n        state.tokens.push(tableToken);\n        if (tableToken.meta.cap) {\n            token = state.push(\"caption_open\", \"caption\", 1);\n            token.map = tableToken.meta.cap.map;\n            var attrs = [];\n            var capSide = tableToken.meta.cap.first ? \"top\" : \"bottom\";\n            /* Null is possible when disabled the option autolabel */ if (tableToken.meta.cap.label !== null) {\n                attrs.push([\n                    \"id\",\n                    tableToken.meta.cap.label\n                ]);\n            }\n            /* Add caption-side inline-CSS to <caption> tag, if caption is below the markdown table. */ if (capSide !== \"top\") {\n                attrs.push([\n                    \"style\",\n                    \"caption-side: \" + capSide\n                ]);\n            }\n            token.attrs = attrs;\n            token = state.push(\"inline\", \"\", 0);\n            token.content = tableToken.meta.cap.text;\n            token.map = tableToken.meta.cap.map;\n            token.children = [];\n            token = state.push(\"caption_close\", \"caption\", -1);\n        }\n        for(r = 0; r < tableToken.meta.tr.length; r++){\n            leftToken = new state.Token(\"td_th_placeholder\", \"\", 0);\n            /* Push in thead/tbody and tr open tokens */ trToken = tableToken.meta.tr[r];\n            // console.log(trToken.meta); // for test\n            if (trToken.meta.grp & 0x10) {\n                tag = trToken.meta.type === 0x00100 ? \"thead\" : \"tbody\";\n                token = state.push(tag + \"_open\", tag, 1);\n                token.map = tgroupLines = [\n                    trToken.map[0],\n                    0\n                ]; // array ref\n                upTokens = [];\n            }\n            trToken.block = true;\n            trToken.level = state.level++;\n            state.tokens.push(trToken);\n            /* Push in th/td tokens */ for(c = 0; c < trToken.meta.bounds.length - 1; c++){\n                range = [\n                    trToken.meta.bounds[c] + 1,\n                    trToken.meta.bounds[c + 1]\n                ];\n                text = state.src.slice.apply(state.src, range);\n                if (text === \"\") {\n                    colspan = leftToken.attrGet(\"colspan\");\n                    leftToken.attrSet(\"colspan\", colspan === null ? 2 : colspan + 1);\n                    continue;\n                }\n                if (options.rowspan && upTokens[c] && text.trim() === \"^^\") {\n                    rowspan = upTokens[c].attrGet(\"rowspan\");\n                    upTokens[c].attrSet(\"rowspan\", rowspan === null ? 2 : rowspan + 1);\n                    leftToken = new state.Token(\"td_th_placeholder\", \"\", 0);\n                    continue;\n                }\n                tag = trToken.meta.type === 0x00100 ? \"th\" : \"td\";\n                token = state.push(tag + \"_open\", tag, 1);\n                token.map = trToken.map;\n                token.attrs = [];\n                if (tableToken.meta.sep.aligns[c]) {\n                    token.attrs.push([\n                        \"style\",\n                        \"text-align:\" + tableToken.meta.sep.aligns[c]\n                    ]);\n                }\n                if (tableToken.meta.sep.wraps[c]) {\n                    token.attrs.push([\n                        \"class\",\n                        \"extend\"\n                    ]);\n                }\n                leftToken = upTokens[c] = token;\n                /* Multiline. Join the text and feed into markdown-it blockParser. */ if (options.multiline && trToken.meta.multiline && trToken.meta.mbounds) {\n                    // Pad the text with empty lines to ensure the line number mapping is correct\n                    text = new Array(trToken.map[0]).fill(\"\").concat([\n                        text.trimRight()\n                    ]);\n                    for(b = 1; b < trToken.meta.mbounds.length; b++){\n                        /* Line with N bounds has cells indexed from 0 to N-2 */ if (c > trToken.meta.mbounds[b].length - 2) {\n                            continue;\n                        }\n                        range = [\n                            trToken.meta.mbounds[b][c] + 1,\n                            trToken.meta.mbounds[b][c + 1]\n                        ];\n                        text.push(state.src.slice.apply(state.src, range).trimRight());\n                    }\n                    blockState = new state.md.block.State(text.join(\"\\n\"), state.md, state.env, []);\n                    blockState.level = trToken.level + 1;\n                    // Start tokenizing from the actual content (trToken.map[0])\n                    state.md.block.tokenize(blockState, trToken.map[0], blockState.lineMax);\n                    for(t = 0; t < blockState.tokens.length; t++){\n                        state.tokens.push(blockState.tokens[t]);\n                    }\n                } else {\n                    token = state.push(\"inline\", \"\", 0);\n                    token.content = text.trim();\n                    token.map = trToken.map;\n                    token.level = trToken.level + 1;\n                    token.children = [];\n                }\n                token = state.push(tag + \"_close\", tag, -1);\n            }\n            /* Push in tr and thead/tbody closed tokens */ state.push(\"tr_close\", \"tr\", -1);\n            if (trToken.meta.grp & 0x01) {\n                tag = trToken.meta.type === 0x00100 ? \"thead\" : \"tbody\";\n                token = state.push(tag + \"_close\", tag, -1);\n                tgroupLines[1] = trToken.map[1];\n            }\n        }\n        tableLines[1] = Math.max(tgroupLines[1], tableToken.meta.sep.map[1], tableToken.meta.cap ? tableToken.meta.cap.map[1] : -1);\n        token = state.push(\"table_close\", \"table\", -1);\n        state.line = tableLines[1];\n        return true;\n    }\n    md.block.ruler.at(\"table\", table, {\n        alt: [\n            \"paragraph\",\n            \"reference\"\n        ]\n    });\n}; /* vim: set ts=2 sw=2 et: */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtbXVsdGltZC10YWJsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLE1BQU1DLG1CQUFPQSxDQUFDO0FBRWxCQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MscUJBQXFCQyxFQUFFLEVBQUVDLE9BQU87SUFDeEQsSUFBSUMsV0FBVztRQUNiQyxXQUFZO1FBQ1pDLFNBQVk7UUFDWkMsWUFBWTtRQUNaQyxXQUFZO1FBQ1pDLFdBQVk7SUFDZDtJQUNBTixVQUFVRCxHQUFHUSxLQUFLLENBQUNDLE1BQU0sQ0FBQyxDQUFDLEdBQUdQLFVBQVVELFdBQVcsQ0FBQztJQUVwRCxTQUFTUyxtQkFBbUJDLEtBQUssRUFBRUMsSUFBSTtRQUNyQzs7Ozs7S0FLQyxHQUNELElBQUlDLFFBQVFGLE1BQU1HLE1BQU0sQ0FBQ0YsS0FBSyxHQUFHRCxNQUFNSSxNQUFNLENBQUNILEtBQUssRUFDL0NJLE9BQU9MLE1BQU1HLE1BQU0sQ0FBQ0YsS0FBSyxHQUFHRCxNQUFNTSxTQUFTLEVBQzNDQyxNQUFNUCxNQUFNUSxjQUFjLENBQUNSLE1BQU1TLE1BQU0sQ0FBQ1IsS0FBSyxFQUFFSSxPQUMvQ0ssU0FBUyxFQUFFLEVBQUVDLEtBQUtDLFNBQ2xCQyxTQUFTLE9BQU9DLE9BQU8sT0FBT0MsU0FBUztRQUUzQywwQ0FBMEMsR0FDMUMsSUFBS0osTUFBTVQsT0FBT1MsTUFBTUosS0FBS0ksTUFBTztZQUNsQyxPQUFRWCxNQUFNZ0IsR0FBRyxDQUFDQyxVQUFVLENBQUNOO2dCQUMzQixLQUFLLEtBQUssS0FBSztvQkFDYkUsU0FBUztvQkFBTTtnQkFDakIsS0FBSyxLQUFLLEtBQUs7b0JBQ2JELFVBQVVaLE1BQU1rQixTQUFTLENBQUNQLEtBQUssUUFBUTtvQkFDdkM7MERBQ2dELEdBQ2hELHdDQUF3QyxHQUN4QyxJQUFJQyxVQUFVRCxLQUFLO3dCQUNqQixJQUFJLENBQUNHLE1BQU07NEJBQ1QsSUFBSUMsV0FBVyxH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RCxVQUFVLENBQUMsRUFBRTtRQUMxQixPQUFPO0lBQ1Q7SUFFQXJFLEdBQUdtRyxLQUFLLENBQUNvQixLQUFLLENBQUNDLEVBQUUsQ0FBQyxTQUFTL0QsT0FBTztRQUFFZ0UsS0FBSztZQUFFO1lBQWE7U0FBYTtJQUFDO0FBQ3hFLEdBRUEsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0LW11bHRpbWQtdGFibGUvaW5kZXguanM/Y2M5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgREZBID0gcmVxdWlyZSgnLi9saWIvZGZhLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbXVsdGltZF90YWJsZV9wbHVnaW4obWQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG11bHRpbGluZTogIGZhbHNlLFxuICAgIHJvd3NwYW46ICAgIGZhbHNlLFxuICAgIGhlYWRlcmxlc3M6IGZhbHNlLFxuICAgIG11bHRpYm9keTogIHRydWUsXG4gICAgYXV0b2xhYmVsOiAgdHJ1ZVxuICB9O1xuICBvcHRpb25zID0gbWQudXRpbHMuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgZnVuY3Rpb24gc2Nhbl9ib3VuZF9pbmRpY2VzKHN0YXRlLCBsaW5lKSB7XG4gICAgLyoqXG4gICAgICogTmFtaW5nIGNvbnZlbnRpb24gb2YgcG9zaXRpb25hbCB2YXJpYWJsZXNcbiAgICAgKiAtIGxpc3QtaXRlbVxuICAgICAqIMK3wrfCt8K3wrfCt8K3wrfCt2xvbmd0ZXh0wrfCt8K3wrfCt8K3XFxuXG4gICAgICogICBeaGVhZCAgXnN0YXJ0ICBeZW5kICBebWF4XG4gICAgICovXG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuc0NvdW50W2xpbmVdLFxuICAgICAgICBoZWFkID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgICBlbmQgPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhzdGF0ZS5lTWFya3NbbGluZV0sIGhlYWQpLFxuICAgICAgICBib3VuZHMgPSBbXSwgcG9zLCBwb3NqdW1wLFxuICAgICAgICBlc2NhcGUgPSBmYWxzZSwgY29kZSA9IGZhbHNlLCBzZXJpYWwgPSAwO1xuXG4gICAgLyogU2NhbiBmb3IgdmFsaWQgcGlwZSBjaGFyYWN0ZXIgcG9zaXRpb24gKi9cbiAgICBmb3IgKHBvcyA9IHN0YXJ0OyBwb3MgPCBlbmQ7IHBvcysrKSB7XG4gICAgICBzd2l0Y2ggKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpIHtcbiAgICAgICAgY2FzZSAweDVjIC8qIFxcICovOlxuICAgICAgICAgIGVzY2FwZSA9IHRydWU7IGJyZWFrO1xuICAgICAgICBjYXNlIDB4NjAgLyogYCAqLzpcbiAgICAgICAgICBwb3NqdW1wID0gc3RhdGUuc2tpcENoYXJzKHBvcywgMHg2MCkgLSAxO1xuICAgICAgICAgIC8qIG1ha2UgXFxgIGNsb3NlcyB0aGUgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAgICAgIHRoZSByZWFzb24gaXMgdGhhdCBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9jayAqL1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBicmFjZS1zdHlsZSAqL1xuICAgICAgICAgIGlmIChwb3NqdW1wID4gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgaWYgKHNlcmlhbCA9PT0gMCkgeyBzZXJpYWwgPSBwb3NqdW1wIC0gcG9zOyB9IGVsc2UgaWYgKHNlcmlhbCA9PT0gcG9zanVtcCAtIHBvcykgeyBzZXJpYWwgPSAwOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBwb3NqdW1wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSB8fCAoIWVzY2FwZSAmJiAhc2VyaWFsKSkgeyBjb2RlID0gIWNvZGU7IH1cbiAgICAgICAgICBlc2NhcGUgPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg3YyAvKiB8ICovOlxuICAgICAgICAgIGlmICghY29kZSAmJiAhZXNjYXBlKSB7IGJvdW5kcy5wdXNoKHBvcyk7IH1cbiAgICAgICAgICBlc2NhcGUgPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXNjYXBlID0gZmFsc2U7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm91bmRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJvdW5kcztcblxuICAgIC8qIFBhZCBpbiBuZXdsaW5lIGNoYXJhY3RlcnMgb24gbGFzdCBhbmQgdGhpcyBsaW5lICovXG4gICAgaWYgKGJvdW5kc1swXSA+IGhlYWQpIHsgYm91bmRzLnVuc2hpZnQoaGVhZCAtIDEpOyB9XG4gICAgaWYgKGJvdW5kc1tib3VuZHMubGVuZ3RoIC0gMV0gPCBlbmQgLSAxKSB7IGJvdW5kcy5wdXNoKGVuZCk7IH1cblxuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBmdW5jdGlvbiB0YWJsZV9jYXB0aW9uKHN0YXRlLCBzaWxlbnQsIGxpbmUpIHtcbiAgICB2YXIgbWV0YSA9IHsgdGV4dDogbnVsbCwgbGFiZWw6IG51bGwgfSxcbiAgICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5zQ291bnRbbGluZV0sXG4gICAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXSxcbiAgICAgICAgLyogQSBub24tZ3JlZWR5IHF1YWxpZmllciBhbGxvd3MgdGhlIGxhYmVsIHRvIGJlIG1hdGNoZWQgKi9cbiAgICAgICAgY2FwUkUgPSAvXlxcWyguKz8pXFxdKFxcWyhbXlxcW1xcXV0rKVxcXSk/XFxzKiQvLFxuICAgICAgICBtYXRjaGVzID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBtYXgpLm1hdGNoKGNhcFJFKTtcblxuICAgIGlmICghbWF0Y2hlcykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoc2lsZW50KSAgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgbWV0YS50ZXh0ICA9IG1hdGNoZXNbMV07XG5cbiAgICBpZiAoIW9wdGlvbnMuYXV0b2xhYmVsICYmICFtYXRjaGVzWzJdKSB7IHJldHVybiBtZXRhOyB9XG5cbiAgICBtZXRhLmxhYmVsID0gbWF0Y2hlc1syXSB8fCBtYXRjaGVzWzFdO1xuICAgIG1ldGEubGFiZWwgPSBtZXRhLmxhYmVsLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxXKy9nLCAnJyk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlX3JvdyhzdGF0ZSwgc2lsZW50LCBsaW5lKSB7XG4gICAgdmFyIG1ldGEgPSB7IGJvdW5kczogbnVsbCwgbXVsdGlsaW5lOiBudWxsIH0sXG4gICAgICAgIGJvdW5kcyA9IHNjYW5fYm91bmRfaW5kaWNlcyhzdGF0ZSwgbGluZSksXG4gICAgICAgIHN0YXJ0LCBwb3MsIG9sZE1heDtcblxuICAgIGlmIChib3VuZHMubGVuZ3RoIDwgMikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICBtZXRhLmJvdW5kcyA9IGJvdW5kcztcblxuICAgIC8qIE11bHRpbGluZS4gU2NhbiBib3VuZGFyaWVzIGFnYWluIHNpbmNlIGl0J3MgdmVyeSBjb21wbGljYXRlZCAqL1xuICAgIGlmIChvcHRpb25zLm11bHRpbGluZSkge1xuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbGluZV0gKyBzdGF0ZS5zQ291bnRbbGluZV07XG4gICAgICBwb3MgPSBzdGF0ZS5lTWFya3NbbGluZV0gLSAxOyAvKiB3aGVyZSBiYWNrc2xhc2ggc2hvdWxkIGJlICovXG4gICAgICBtZXRhLm11bHRpbGluZSA9IChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVDLyogXFwgKi8pO1xuICAgICAgaWYgKG1ldGEubXVsdGlsaW5lKSB7XG4gICAgICAgIG9sZE1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcbiAgICAgICAgc3RhdGUuZU1hcmtzW2xpbmVdID0gc3RhdGUuc2tpcFNwYWNlc0JhY2socG9zLCBzdGFydCk7XG4gICAgICAgIG1ldGEuYm91bmRzID0gc2Nhbl9ib3VuZF9pbmRpY2VzKHN0YXRlLCBsaW5lKTtcbiAgICAgICAgc3RhdGUuZU1hcmtzW2xpbmVdID0gb2xkTWF4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFibGVfc2VwYXJhdG9yKHN0YXRlLCBzaWxlbnQsIGxpbmUpIHtcbiAgICB2YXIgbWV0YSA9IHsgYWxpZ25zOiBbXSwgd3JhcHM6IFtdIH0sXG4gICAgICAgIGJvdW5kcyA9IHNjYW5fYm91bmRfaW5kaWNlcyhzdGF0ZSwgbGluZSksXG4gICAgICAgIHNlcFJFID0gL146PygtK3w9Kyk6P1xcKz8kLyxcbiAgICAgICAgYywgdGV4dCwgYWxpZ247XG5cbiAgICAvKiBPbmx5IHNlcGFyYXRvciBuZWVkcyB0byBjaGVjayBpbmRlbnRzICovXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChib3VuZHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgZm9yIChjID0gMDsgYyA8IGJvdW5kcy5sZW5ndGggLSAxOyBjKyspIHtcbiAgICAgIHRleHQgPSBzdGF0ZS5zcmMuc2xpY2UoYm91bmRzW2NdICsgMSwgYm91bmRzW2MgKyAxXSkudHJpbSgpO1xuICAgICAgaWYgKCFzZXBSRS50ZXN0KHRleHQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICBtZXRhLndyYXBzLnB1c2godGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSkgPT09IDB4MkIvKiArICovKTtcbiAgICAgIGFsaWduID0gKCh0ZXh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovKSA8PCA0KSB8XG4gICAgICAgICAgICAgICAodGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSAtIG1ldGEud3JhcHNbY10pID09PSAweDNBKTtcbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAweDAwOiBtZXRhLmFsaWducy5wdXNoKCcnKTsgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMTogbWV0YS5hbGlnbnMucHVzaCgncmlnaHQnKTsgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6IG1ldGEuYWxpZ25zLnB1c2goJ2xlZnQnKTsgICBicmVhaztcbiAgICAgICAgY2FzZSAweDExOiBtZXRhLmFsaWducy5wdXNoKCdjZW50ZXInKTsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlX2VtcHR5KHN0YXRlLCBzaWxlbnQsIGxpbmUpIHtcbiAgICByZXR1cm4gc3RhdGUuaXNFbXB0eShsaW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICAgIC8qKlxuICAgICAqIFJlZ2V4IHBzZXVkbyBjb2RlIGZvciB0YWJsZTpcbiAgICAgKiAgICAgY2FwdGlvbj8gaGVhZGVyKyBzZXBhcmF0b3IgKGRhdGErIGVtcHR5KSogZGF0YSsgY2FwdGlvbj9cbiAgICAgKlxuICAgICAqIFdlIHVzZSBERkEgdG8gZW11bGF0ZSB0aGlzIHBsdWdpbi4gVHlwZXMgd2l0aCBsb3dlciBwcmVjZWRlbmNlIGFyZVxuICAgICAqIHNldC1taW51cyBmcm9tIGFsbCB0aGUgZm9ybWVycy4gIE5vdGVkIHRoYXQgc2VwYXJhdG9yIHNob3VsZCBoYXZlIGhpZ2hlclxuICAgICAqIHByZWNlZGVuY2UgdGhhbiBoZWFkZXIgb3IgZGF0YS5cbiAgICAgKiAgIHwgIHN0YXRlICB8IGNhcHRpb24gc2VwYXJhdG9yIGhlYWRlciBkYXRhIGVtcHR5IHwgLS0+IGxvd2VyIHByZWNlZGVuY2VcbiAgICAgKiAgIHwgMHgxMDEwMCB8ICAgIDEgICAgICAgIDAgICAgICAgMSAgICAgMCAgICAgMCAgIHxcbiAgICAgKi9cbiAgICB2YXIgdGFibGVERkEgPSBuZXcgREZBKCksXG4gICAgICAgIGdycCA9IDB4MTAsIG10ciA9IC0xLFxuICAgICAgICB0b2tlbiwgdGFibGVUb2tlbiwgdHJUb2tlbixcbiAgICAgICAgY29sc3BhbiwgbGVmdFRva2VuLFxuICAgICAgICByb3dzcGFuLCB1cFRva2VucyA9IFtdLFxuICAgICAgICB0YWJsZUxpbmVzLCB0Z3JvdXBMaW5lcyxcbiAgICAgICAgdGFnLCB0ZXh0LCByYW5nZSwgciwgYywgYiwgdCxcbiAgICAgICAgYmxvY2tTdGF0ZTtcblxuICAgIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8qKlxuICAgICAqIEZpcnN0IHBhc3M6IHZhbGlkYXRlIGFuZCBjb2xsZWN0IGluZm8gaW50byB0YWJsZSB0b2tlbi4gSVIgaXMgc3RvcmVkIGluXG4gICAgICogbWFya2Rvd24taXQgYHRva2VuLm1ldGFgIHRvIGJlIHB1c2hlZCBsYXRlci4gdGFibGUvdHIgb3BlbiB0b2tlbnMgYXJlXG4gICAgICogZ2VuZXJhdGVkIGhlcmUuXG4gICAgICovXG4gICAgdGFibGVUb2tlbiAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGFibGVfb3BlbicsICd0YWJsZScsIDEpO1xuICAgIHRhYmxlVG9rZW4ubWV0YSAgPSB7IHNlcDogbnVsbCwgY2FwOiBudWxsLCB0cjogW10gfTtcblxuICAgIHRhYmxlREZBLnNldF9oaWdoZXN0X2FscGhhYmV0KDB4MTAwMDApO1xuICAgIHRhYmxlREZBLnNldF9pbml0aWFsX3N0YXRlKDB4MTAxMDApO1xuICAgIHRhYmxlREZBLnNldF9hY2NlcHRfc3RhdGVzKFsgMHgxMDAxMCwgMHgxMDAxMSwgMHgwMDAwMCBdKTtcbiAgICB0YWJsZURGQS5zZXRfbWF0Y2hfYWxwaGFiZXRzKHtcbiAgICAgIDB4MTAwMDA6IHRhYmxlX2NhcHRpb24uYmluZCh0aGlzLCBzdGF0ZSwgdHJ1ZSksXG4gICAgICAweDAxMDAwOiB0YWJsZV9zZXBhcmF0b3IuYmluZCh0aGlzLCBzdGF0ZSwgdHJ1ZSksXG4gICAgICAweDAwMTAwOiB0YWJsZV9yb3cuYmluZCh0aGlzLCBzdGF0ZSwgdHJ1ZSksXG4gICAgICAweDAwMDEwOiB0YWJsZV9yb3cuYmluZCh0aGlzLCBzdGF0ZSwgdHJ1ZSksXG4gICAgICAweDAwMDAxOiB0YWJsZV9lbXB0eS5iaW5kKHRoaXMsIHN0YXRlLCB0cnVlKVxuICAgIH0pO1xuICAgIHRhYmxlREZBLnNldF90cmFuc2l0aW9ucyh7XG4gICAgICAweDEwMTAwOiB7IDB4MTAwMDA6IDB4MDAxMDAsIDB4MDAxMDA6IDB4MDExMDAgfSxcbiAgICAgIDB4MDAxMDA6IHsgMHgwMDEwMDogMHgwMTEwMCB9LFxuICAgICAgMHgwMTEwMDogeyAweDAxMDAwOiAweDEwMDEwLCAweDAwMTAwOiAweDAxMTAwIH0sXG4gICAgICAweDEwMDEwOiB7IDB4MTAwMDA6IDB4MDAwMDAsIDB4MDAwMTA6IDB4MTAwMTEgfSxcbiAgICAgIDB4MTAwMTE6IHsgMHgxMDAwMDogMHgwMDAwMCwgMHgwMDAxMDogMHgxMDAxMSwgMHgwMDAwMTogMHgxMDAxMCB9XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVybGVzcykge1xuICAgICAgdGFibGVERkEuc2V0X2luaXRpYWxfc3RhdGUoMHgxMTEwMCk7XG4gICAgICB0YWJsZURGQS51cGRhdGVfdHJhbnNpdGlvbigweDExMTAwLFxuICAgICAgICB7IDB4MTAwMDA6IDB4MDExMDAsIDB4MDEwMDA6IDB4MTAwMTAsIDB4MDAxMDA6IDB4MDExMDAgfVxuICAgICAgKTtcbiAgICAgIHRyVG9rZW4gICAgICA9IG5ldyBzdGF0ZS5Ub2tlbigndHJfcGxhY2Vob2xkZXInLCAndHInLCAwKTtcbiAgICAgIHRyVG9rZW4ubWV0YSA9IE9iamVjdCgpOyAgLy8gYXZvaWQgdHJUb2tlbi5tZXRhLmdycCB0aHJvd3MgZXhjZXB0aW9uXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5tdWx0aWJvZHkpIHtcbiAgICAgIHRhYmxlREZBLnVwZGF0ZV90cmFuc2l0aW9uKDB4MTAwMTAsXG4gICAgICAgIHsgMHgxMDAwMDogMHgwMDAwMCwgMHgwMDAxMDogMHgxMDAxMCB9ICAvLyAweDEwMDExIGlzIG5ldmVyIHJlYWNoZWRcbiAgICAgICk7XG4gICAgfVxuICAgIC8qIERvbid0IG1peCB1cCBERkEgYF9zdGF0ZWAgYW5kIG1hcmtkb3duLWl0IGBzdGF0ZWAgKi9cbiAgICB0YWJsZURGQS5zZXRfYWN0aW9ucyhmdW5jdGlvbiAoX2xpbmUsIF9zdGF0ZSwgX3R5cGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKF9saW5lLCBfc3RhdGUudG9TdHJpbmcoMTYpLCBfdHlwZS50b1N0cmluZygxNikpICAvLyBmb3IgdGVzdFxuICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICBjYXNlIDB4MTAwMDA6XG4gICAgICAgICAgaWYgKHRhYmxlVG9rZW4ubWV0YS5jYXApIHsgYnJlYWs7IH1cbiAgICAgICAgICB0YWJsZVRva2VuLm1ldGEuY2FwICAgICAgID0gdGFibGVfY2FwdGlvbihzdGF0ZSwgZmFsc2UsIF9saW5lKTtcbiAgICAgICAgICB0YWJsZVRva2VuLm1ldGEuY2FwLm1hcCAgID0gWyBfbGluZSwgX2xpbmUgKyAxIF07XG4gICAgICAgICAgdGFibGVUb2tlbi5tZXRhLmNhcC5maXJzdCA9IChfbGluZSA9PT0gc3RhcnRMaW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAxMDAwOlxuICAgICAgICAgIHRhYmxlVG9rZW4ubWV0YS5zZXAgICAgID0gdGFibGVfc2VwYXJhdG9yKHN0YXRlLCBmYWxzZSwgX2xpbmUpO1xuICAgICAgICAgIHRhYmxlVG9rZW4ubWV0YS5zZXAubWFwID0gWyBfbGluZSwgX2xpbmUgKyAxIF07XG4gICAgICAgICAgdHJUb2tlbi5tZXRhLmdycCB8PSAweDAxOyAgLy8gcHJldmlvdXNseSBhc3NpZ25lZCBhdCBjYXNlIDB4MDAxMTBcbiAgICAgICAgICBncnAgICAgICAgICAgICAgICA9IDB4MTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMDEwMDpcbiAgICAgICAgY2FzZSAweDAwMDEwOlxuICAgICAgICAgIHRyVG9rZW4gICAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgICAgICAgdHJUb2tlbi5tYXAgICAgICAgPSBbIF9saW5lLCBfbGluZSArIDEgXTtcbiAgICAgICAgICB0clRva2VuLm1ldGEgICAgICA9IHRhYmxlX3JvdyhzdGF0ZSwgZmFsc2UsIF9saW5lKTtcbiAgICAgICAgICB0clRva2VuLm1ldGEudHlwZSA9IF90eXBlO1xuICAgICAgICAgIHRyVG9rZW4ubWV0YS5ncnAgID0gZ3JwO1xuICAgICAgICAgIGdycCAgICAgICAgICAgICAgID0gMHgwMDtcbiAgICAgICAgICB0YWJsZVRva2VuLm1ldGEudHIucHVzaCh0clRva2VuKTtcbiAgICAgICAgICAvKiBNdWx0aWxpbmUuIE1lcmdlIHRyVG9rZW5zIGFzIGFuIGVudGlyZSBtdWx0aWxpbmUgdHJUb2tlbiAqL1xuICAgICAgICAgIGlmIChvcHRpb25zLm11bHRpbGluZSkge1xuICAgICAgICAgICAgaWYgKHRyVG9rZW4ubWV0YS5tdWx0aWxpbmUgJiYgbXRyIDwgMCkge1xuICAgICAgICAgICAgICAvKiBTdGFydCBsaW5lIG9mIG11bHRpbGluZSByb3cuIG1hcmsgdGhpcyB0clRva2VuICovXG4gICAgICAgICAgICAgIG10ciA9IHRhYmxlVG9rZW4ubWV0YS50ci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdHJUb2tlbi5tZXRhLm11bHRpbGluZSAmJiBtdHIgPj0gMCkge1xuICAgICAgICAgICAgICAvKiBFbmQgbGluZSBvZiBtdWx0aWxpbmUgcm93LiBtZXJnZSBmb3J3YXJkIHVudGlsIHRoZSBtYXJrZWQgdHJUb2tlbiAqL1xuICAgICAgICAgICAgICB0b2tlbiAgICAgICAgICAgICAgID0gdGFibGVUb2tlbi5tZXRhLnRyW210cl07XG4gICAgICAgICAgICAgIHRva2VuLm1ldGEubWJvdW5kcyAgPSB0YWJsZVRva2VuLm1ldGEudHJcbiAgICAgICAgICAgICAgICAuc2xpY2UobXRyKS5tYXAoZnVuY3Rpb24gKHRrKSB7IHJldHVybiB0ay5tZXRhLmJvdW5kczsgfSk7XG4gICAgICAgICAgICAgIHRva2VuLm1hcFsxXSAgICAgICAgPSB0clRva2VuLm1hcFsxXTtcbiAgICAgICAgICAgICAgdGFibGVUb2tlbi5tZXRhLnRyICA9IHRhYmxlVG9rZW4ubWV0YS50ci5zbGljZSgwLCBtdHIgKyAxKTtcbiAgICAgICAgICAgICAgbXRyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDAwMDE6XG4gICAgICAgICAgdHJUb2tlbi5tZXRhLmdycCB8PSAweDAxO1xuICAgICAgICAgIGdycCAgICAgICAgICAgICAgID0gMHgxMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0YWJsZURGQS5leGVjdXRlKHN0YXJ0TGluZSwgZW5kTGluZSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmICghdGFibGVUb2tlbi5tZXRhLnNlcCkgeyByZXR1cm4gZmFsc2U7IH0gLy8gYWx3YXlzIGV2YWx1YXRlZCB0cnVlXG4gICAgaWYgKCF0YWJsZVRva2VuLm1ldGEudHIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBmYWxzZSB1bmRlciBoZWFkZXJsZXNzIGNvcm5lciBjYXNlXG4gICAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgLyogTGFzdCBkYXRhIHJvdyBjYW5ub3QgYmUgZGV0ZWN0ZWQuIG5vdCBzdG9yZWQgdG8gdHJUb2tlbiBvdXRzaWRlPyAqL1xuICAgIHRhYmxlVG9rZW4ubWV0YS50clt0YWJsZVRva2VuLm1ldGEudHIubGVuZ3RoIC0gMV0ubWV0YS5ncnAgfD0gMHgwMTtcblxuXG4gICAgLyoqXG4gICAgICogU2Vjb25kIHBhc3M6IGFjdHVhbGx5IHB1c2ggdGhlIHRva2VucyBpbnRvIGBzdGF0ZS50b2tlbnNgLlxuICAgICAqIHRoZWFkL3Rib2R5L3RoL3RkIG9wZW4gdG9rZW5zIGFuZCBhbGwgY2xvc2VkIHRva2VucyBhcmUgZ2VuZXJhdGVkIGhlcmU7XG4gICAgICogdGhlYWQvdGJvZHkgYXJlIGdlbmVyYWxseSBjYWxsZWQgdGdyb3VwOyB0ZC90aCBhcmUgZ2VuZXJhbGx5IGNhbGxlZCB0Y29sLlxuICAgICAqL1xuICAgIHRhYmxlVG9rZW4ubWFwICAgPSB0YWJsZUxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcbiAgICB0YWJsZVRva2VuLmJsb2NrID0gdHJ1ZTtcbiAgICB0YWJsZVRva2VuLmxldmVsID0gc3RhdGUubGV2ZWwrKztcbiAgICBzdGF0ZS50b2tlbnMucHVzaCh0YWJsZVRva2VuKTtcblxuICAgIGlmICh0YWJsZVRva2VuLm1ldGEuY2FwKSB7XG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2NhcHRpb25fb3BlbicsICdjYXB0aW9uJywgMSk7XG4gICAgICB0b2tlbi5tYXAgICAgICA9IHRhYmxlVG9rZW4ubWV0YS5jYXAubWFwO1xuXG4gICAgICB2YXIgYXR0cnMgICAgICA9IFtdO1xuICAgICAgdmFyIGNhcFNpZGUgICAgPSB0YWJsZVRva2VuLm1ldGEuY2FwLmZpcnN0ID8gJ3RvcCcgOiAnYm90dG9tJztcblxuICAgICAgLyogTnVsbCBpcyBwb3NzaWJsZSB3aGVuIGRpc2FibGVkIHRoZSBvcHRpb24gYXV0b2xhYmVsICovXG4gICAgICBpZiAodGFibGVUb2tlbi5tZXRhLmNhcC5sYWJlbCAhPT0gbnVsbCkge1xuICAgICAgICBhdHRycy5wdXNoKFsgJ2lkJywgdGFibGVUb2tlbi5tZXRhLmNhcC5sYWJlbCBdKTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkIGNhcHRpb24tc2lkZSBpbmxpbmUtQ1NTIHRvIDxjYXB0aW9uPiB0YWcsIGlmIGNhcHRpb24gaXMgYmVsb3cgdGhlIG1hcmtkb3duIHRhYmxlLiAqL1xuICAgICAgaWYgKGNhcFNpZGUgIT09ICd0b3AnKSB7XG4gICAgICAgIGF0dHJzLnB1c2goWyAnc3R5bGUnLCAnY2FwdGlvbi1zaWRlOiAnICsgY2FwU2lkZSBdKTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4uYXR0cnMgICAgPSBhdHRycztcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IHRhYmxlVG9rZW4ubWV0YS5jYXAudGV4dDtcbiAgICAgIHRva2VuLm1hcCAgICAgID0gdGFibGVUb2tlbi5tZXRhLmNhcC5tYXA7XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2NhcHRpb25fY2xvc2UnLCAnY2FwdGlvbicsIC0xKTtcbiAgICB9XG5cbiAgICBmb3IgKHIgPSAwOyByIDwgdGFibGVUb2tlbi5tZXRhLnRyLmxlbmd0aDsgcisrKSB7XG4gICAgICBsZWZ0VG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ3RkX3RoX3BsYWNlaG9sZGVyJywgJycsIDApO1xuXG4gICAgICAvKiBQdXNoIGluIHRoZWFkL3Rib2R5IGFuZCB0ciBvcGVuIHRva2VucyAqL1xuICAgICAgdHJUb2tlbiA9IHRhYmxlVG9rZW4ubWV0YS50cltyXTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRyVG9rZW4ubWV0YSk7IC8vIGZvciB0ZXN0XG4gICAgICBpZiAodHJUb2tlbi5tZXRhLmdycCAmIDB4MTApIHtcbiAgICAgICAgdGFnID0gKHRyVG9rZW4ubWV0YS50eXBlID09PSAweDAwMTAwKSA/ICd0aGVhZCcgOiAndGJvZHknO1xuICAgICAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKHRhZyArICdfb3BlbicsIHRhZywgMSk7XG4gICAgICAgIHRva2VuLm1hcCA9IHRncm91cExpbmVzID0gWyB0clRva2VuLm1hcFswXSwgMCBdOyAgLy8gYXJyYXkgcmVmXG4gICAgICAgIHVwVG9rZW5zICA9IFtdO1xuICAgICAgfVxuICAgICAgdHJUb2tlbi5ibG9jayA9IHRydWU7XG4gICAgICB0clRva2VuLmxldmVsID0gc3RhdGUubGV2ZWwrKztcbiAgICAgIHN0YXRlLnRva2Vucy5wdXNoKHRyVG9rZW4pO1xuXG4gICAgICAvKiBQdXNoIGluIHRoL3RkIHRva2VucyAqL1xuICAgICAgZm9yIChjID0gMDsgYyA8IHRyVG9rZW4ubWV0YS5ib3VuZHMubGVuZ3RoIC0gMTsgYysrKSB7XG4gICAgICAgIHJhbmdlID0gWyB0clRva2VuLm1ldGEuYm91bmRzW2NdICsgMSwgdHJUb2tlbi5tZXRhLmJvdW5kc1tjICsgMV0gXTtcbiAgICAgICAgdGV4dCA9IHN0YXRlLnNyYy5zbGljZS5hcHBseShzdGF0ZS5zcmMsIHJhbmdlKTtcblxuICAgICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgICBjb2xzcGFuID0gbGVmdFRva2VuLmF0dHJHZXQoJ2NvbHNwYW4nKTtcbiAgICAgICAgICBsZWZ0VG9rZW4uYXR0clNldCgnY29sc3BhbicsIGNvbHNwYW4gPT09IG51bGwgPyAyIDogY29sc3BhbiArIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJvd3NwYW4gJiYgdXBUb2tlbnNbY10gJiYgdGV4dC50cmltKCkgPT09ICdeXicpIHtcbiAgICAgICAgICByb3dzcGFuID0gdXBUb2tlbnNbY10uYXR0ckdldCgncm93c3BhbicpO1xuICAgICAgICAgIHVwVG9rZW5zW2NdLmF0dHJTZXQoJ3Jvd3NwYW4nLCByb3dzcGFuID09PSBudWxsID8gMiA6IHJvd3NwYW4gKyAxKTtcbiAgICAgICAgICBsZWZ0VG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oJ3RkX3RoX3BsYWNlaG9sZGVyJywgJycsIDApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFnID0gKHRyVG9rZW4ubWV0YS50eXBlID09PSAweDAwMTAwKSA/ICd0aCcgOiAndGQnO1xuICAgICAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2godGFnICsgJ19vcGVuJywgdGFnLCAxKTtcbiAgICAgICAgdG9rZW4ubWFwICAgPSB0clRva2VuLm1hcDtcbiAgICAgICAgdG9rZW4uYXR0cnMgPSBbXTtcbiAgICAgICAgaWYgKHRhYmxlVG9rZW4ubWV0YS5zZXAuYWxpZ25zW2NdKSB7XG4gICAgICAgICAgdG9rZW4uYXR0cnMucHVzaChbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyB0YWJsZVRva2VuLm1ldGEuc2VwLmFsaWduc1tjXSBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFibGVUb2tlbi5tZXRhLnNlcC53cmFwc1tjXSkge1xuICAgICAgICAgIHRva2VuLmF0dHJzLnB1c2goWyAnY2xhc3MnLCAnZXh0ZW5kJyBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZnRUb2tlbiA9IHVwVG9rZW5zW2NdID0gdG9rZW47XG5cbiAgICAgICAgLyogTXVsdGlsaW5lLiBKb2luIHRoZSB0ZXh0IGFuZCBmZWVkIGludG8gbWFya2Rvd24taXQgYmxvY2tQYXJzZXIuICovXG4gICAgICAgIGlmIChvcHRpb25zLm11bHRpbGluZSAmJiB0clRva2VuLm1ldGEubXVsdGlsaW5lICYmIHRyVG9rZW4ubWV0YS5tYm91bmRzKSB7XG4gICAgICAgICAgLy8gUGFkIHRoZSB0ZXh0IHdpdGggZW1wdHkgbGluZXMgdG8gZW5zdXJlIHRoZSBsaW5lIG51bWJlciBtYXBwaW5nIGlzIGNvcnJlY3RcbiAgICAgICAgICB0ZXh0ID0gbmV3IEFycmF5KHRyVG9rZW4ubWFwWzBdKS5maWxsKCcnKS5jb25jYXQoWyB0ZXh0LnRyaW1SaWdodCgpIF0pO1xuICAgICAgICAgIGZvciAoYiA9IDE7IGIgPCB0clRva2VuLm1ldGEubWJvdW5kcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgLyogTGluZSB3aXRoIE4gYm91bmRzIGhhcyBjZWxscyBpbmRleGVkIGZyb20gMCB0byBOLTIgKi9cbiAgICAgICAgICAgIGlmIChjID4gdHJUb2tlbi5tZXRhLm1ib3VuZHNbYl0ubGVuZ3RoIC0gMikgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgcmFuZ2UgPSBbIHRyVG9rZW4ubWV0YS5tYm91bmRzW2JdW2NdICsgMSwgdHJUb2tlbi5tZXRhLm1ib3VuZHNbYl1bYyArIDFdIF07XG4gICAgICAgICAgICB0ZXh0LnB1c2goc3RhdGUuc3JjLnNsaWNlLmFwcGx5KHN0YXRlLnNyYywgcmFuZ2UpLnRyaW1SaWdodCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYmxvY2tTdGF0ZSA9IG5ldyBzdGF0ZS5tZC5ibG9jay5TdGF0ZSh0ZXh0LmpvaW4oJ1xcbicpLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBbXSk7XG4gICAgICAgICAgYmxvY2tTdGF0ZS5sZXZlbCA9IHRyVG9rZW4ubGV2ZWwgKyAxO1xuICAgICAgICAgIC8vIFN0YXJ0IHRva2VuaXppbmcgZnJvbSB0aGUgYWN0dWFsIGNvbnRlbnQgKHRyVG9rZW4ubWFwWzBdKVxuICAgICAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKGJsb2NrU3RhdGUsIHRyVG9rZW4ubWFwWzBdLCBibG9ja1N0YXRlLmxpbmVNYXgpO1xuICAgICAgICAgIGZvciAodCA9IDA7IHQgPCBibG9ja1N0YXRlLnRva2Vucy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgc3RhdGUudG9rZW5zLnB1c2goYmxvY2tTdGF0ZS50b2tlbnNbdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ICA9IHRleHQudHJpbSgpO1xuICAgICAgICAgIHRva2VuLm1hcCAgICAgID0gdHJUb2tlbi5tYXA7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICAgPSB0clRva2VuLmxldmVsICsgMTtcbiAgICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKHRhZyArICdfY2xvc2UnLCB0YWcsIC0xKTtcbiAgICAgIH1cblxuICAgICAgLyogUHVzaCBpbiB0ciBhbmQgdGhlYWQvdGJvZHkgY2xvc2VkIHRva2VucyAqL1xuICAgICAgc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gICAgICBpZiAodHJUb2tlbi5tZXRhLmdycCAmIDB4MDEpIHtcbiAgICAgICAgdGFnID0gKHRyVG9rZW4ubWV0YS50eXBlID09PSAweDAwMTAwKSA/ICd0aGVhZCcgOiAndGJvZHknO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2godGFnICsgJ19jbG9zZScsIHRhZywgLTEpO1xuICAgICAgICB0Z3JvdXBMaW5lc1sxXSA9IHRyVG9rZW4ubWFwWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhYmxlTGluZXNbMV0gPSBNYXRoLm1heChcbiAgICAgIHRncm91cExpbmVzWzFdLFxuICAgICAgdGFibGVUb2tlbi5tZXRhLnNlcC5tYXBbMV0sXG4gICAgICB0YWJsZVRva2VuLm1ldGEuY2FwID8gdGFibGVUb2tlbi5tZXRhLmNhcC5tYXBbMV0gOiAtMVxuICAgICk7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0YWJsZV9jbG9zZScsICd0YWJsZScsIC0xKTtcblxuICAgIHN0YXRlLmxpbmUgPSB0YWJsZUxpbmVzWzFdO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbWQuYmxvY2sucnVsZXIuYXQoJ3RhYmxlJywgdGFibGUsIHsgYWx0OiBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJyBdIH0pO1xufTtcblxuLyogdmltOiBzZXQgdHM9MiBzdz0yIGV0OiAqL1xuIl0sIm5hbWVzIjpbIkRGQSIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibXVsdGltZF90YWJsZV9wbHVnaW4iLCJtZCIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsIm11bHRpbGluZSIsInJvd3NwYW4iLCJoZWFkZXJsZXNzIiwibXVsdGlib2R5IiwiYXV0b2xhYmVsIiwidXRpbHMiLCJhc3NpZ24iLCJzY2FuX2JvdW5kX2luZGljZXMiLCJzdGF0ZSIsImxpbmUiLCJzdGFydCIsImJNYXJrcyIsInNDb3VudCIsImhlYWQiLCJibGtJbmRlbnQiLCJlbmQiLCJza2lwU3BhY2VzQmFjayIsImVNYXJrcyIsImJvdW5kcyIsInBvcyIsInBvc2p1bXAiLCJlc2NhcGUiLCJjb2RlIiwic2VyaWFsIiwic3JjIiwiY2hhckNvZGVBdCIsInNraXBDaGFycyIsInB1c2giLCJsZW5ndGgiLCJ1bnNoaWZ0IiwidGFibGVfY2FwdGlvbiIsInNpbGVudCIsIm1ldGEiLCJ0ZXh0IiwibGFiZWwiLCJtYXgiLCJjYXBSRSIsIm1hdGNoZXMiLCJzbGljZSIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJyZXBsYWNlIiwidGFibGVfcm93Iiwib2xkTWF4IiwidGFibGVfc2VwYXJhdG9yIiwiYWxpZ25zIiwid3JhcHMiLCJzZXBSRSIsImMiLCJhbGlnbiIsInRyaW0iLCJ0ZXN0IiwidGFibGVfZW1wdHkiLCJpc0VtcHR5IiwidGFibGUiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwidGFibGVERkEiLCJncnAiLCJtdHIiLCJ0b2tlbiIsInRhYmxlVG9rZW4iLCJ0clRva2VuIiwiY29sc3BhbiIsImxlZnRUb2tlbiIsInVwVG9rZW5zIiwidGFibGVMaW5lcyIsInRncm91cExpbmVzIiwidGFnIiwicmFuZ2UiLCJyIiwiYiIsInQiLCJibG9ja1N0YXRlIiwiVG9rZW4iLCJzZXAiLCJjYXAiLCJ0ciIsInNldF9oaWdoZXN0X2FscGhhYmV0Iiwic2V0X2luaXRpYWxfc3RhdGUiLCJzZXRfYWNjZXB0X3N0YXRlcyIsInNldF9tYXRjaF9hbHBoYWJldHMiLCJiaW5kIiwic2V0X3RyYW5zaXRpb25zIiwidXBkYXRlX3RyYW5zaXRpb24iLCJPYmplY3QiLCJzZXRfYWN0aW9ucyIsIl9saW5lIiwiX3N0YXRlIiwiX3R5cGUiLCJtYXAiLCJmaXJzdCIsInR5cGUiLCJtYm91bmRzIiwidGsiLCJleGVjdXRlIiwiYmxvY2siLCJsZXZlbCIsInRva2VucyIsImF0dHJzIiwiY2FwU2lkZSIsImNvbnRlbnQiLCJjaGlsZHJlbiIsImFwcGx5IiwiYXR0ckdldCIsImF0dHJTZXQiLCJBcnJheSIsImZpbGwiLCJjb25jYXQiLCJ0cmltUmlnaHQiLCJTdGF0ZSIsImpvaW4iLCJlbnYiLCJ0b2tlbml6ZSIsImxpbmVNYXgiLCJNYXRoIiwicnVsZXIiLCJhdCIsImFsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/markdown-it-multimd-table/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/markdown-it-multimd-table/lib/dfa.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it-multimd-table/lib/dfa.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\n// constructor\nfunction DFA() {\n    // alphabets are encoded by numbers in 16^N form, presenting its precedence\n    this.__highest_alphabet__ = 0x0;\n    this.__match_alphabets__ = {};\n    // states are union (bitwise OR) of its accepted alphabets\n    this.__initial_state__ = 0x0;\n    this.__accept_states__ = {};\n    // transitions are in the form: {prev_state: {alphabet: next_state}}\n    this.__transitions__ = {};\n    // actions take two parameters: step (line number), prev_state and alphabet\n    this.__actions__ = {};\n}\n// setters\nDFA.prototype.set_highest_alphabet = function(alphabet) {\n    this.__highest_alphabet__ = alphabet;\n};\nDFA.prototype.set_match_alphabets = function(matches) {\n    this.__match_alphabets__ = matches;\n};\nDFA.prototype.set_initial_state = function(initial) {\n    this.__initial_state__ = initial;\n};\nDFA.prototype.set_accept_states = function(accepts) {\n    for(var i = 0; i < accepts.length; i++){\n        this.__accept_states__[accepts[i]] = true;\n    }\n};\nDFA.prototype.set_transitions = function(transitions) {\n    this.__transitions__ = transitions;\n};\nDFA.prototype.set_actions = function(actions) {\n    this.__actions__ = actions;\n};\nDFA.prototype.update_transition = function(state, alphabets) {\n    this.__transitions__[state] = Object.assign(this.__transitions__[state] || Object(), alphabets);\n};\n// methods\nDFA.prototype.execute = function(start, end) {\n    var state, step, alphabet;\n    for(state = this.__initial_state__, step = start; state && step < end; step++){\n        for(alphabet = this.__highest_alphabet__; alphabet > 0x0; alphabet >>= 4){\n            if (state & alphabet && this.__match_alphabets__[alphabet].call(this, step, state, alphabet)) {\n                break;\n            }\n        }\n        this.__actions__(step, state, alphabet);\n        if (alphabet === 0x0) {\n            break;\n        }\n        state = this.__transitions__[state][alphabet] || 0x0;\n    }\n    return !!this.__accept_states__[state];\n};\nmodule.exports = DFA; /* vim: set ts=2 sw=2 et: */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtbXVsdGltZC10YWJsZS9saWIvZGZhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsY0FBYztBQUVkLFNBQVNBO0lBQ1AsMkVBQTJFO0lBQzNFLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7SUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxDQUFDO0lBQzVCLDBEQUEwRDtJQUMxRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHO0lBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsQ0FBQztJQUMxQixvRUFBb0U7SUFDcEUsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQztJQUN4QiwyRUFBMkU7SUFDM0UsSUFBSSxDQUFDQyxXQUFXLEdBQUcsQ0FBQztBQUN0QjtBQUVBLFVBQVU7QUFFVk4sSUFBSU8sU0FBUyxDQUFDQyxvQkFBb0IsR0FBRyxTQUFVQyxRQUFRO0lBQ3JELElBQUksQ0FBQ1Isb0JBQW9CLEdBQUdRO0FBQzlCO0FBRUFULElBQUlPLFNBQVMsQ0FBQ0csbUJBQW1CLEdBQUcsU0FBVUMsT0FBTztJQUNuRCxJQUFJLENBQUNULG1CQUFtQixHQUFHUztBQUM3QjtBQUVBWCxJQUFJTyxTQUFTLENBQUNLLGlCQUFpQixHQUFHLFNBQVVDLE9BQU87SUFDakQsSUFBSSxDQUFDVixpQkFBaUIsR0FBR1U7QUFDM0I7QUFFQWIsSUFBSU8sU0FBUyxDQUFDTyxpQkFBaUIsR0FBRyxTQUFVQyxPQUFPO0lBQ2pELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxRQUFRRSxNQUFNLEVBQUVELElBQUs7UUFDdkMsSUFBSSxDQUFDWixpQkFBaUIsQ0FBQ1csT0FBTyxDQUFDQyxFQUFFLENBQUMsR0FBRztJQUN2QztBQUNGO0FBRUFoQixJQUFJTyxTQUFTLENBQUNXLGVBQWUsR0FBRyxTQUFVQyxXQUFXO0lBQ25ELElBQUksQ0FBQ2QsZUFBZSxHQUFHYztBQUN6QjtBQUVBbkIsSUFBSU8sU0FBUyxDQUFDYSxXQUFXLEdBQUcsU0FBVUMsT0FBTztJQUMzQyxJQUFJLENBQUNmLFdBQVcsR0FBR2U7QUFDckI7QUFFQXJCLElBQUlPLFNBQVMsQ0FBQ2UsaUJBQWlCLEdBQUcsU0FBVUMsS0FBSyxFQUFFQyxTQUFTO0lBQzFELElBQUksQ0FBQ25CLGVBQWUsQ0FBQ2tCLE1BQU0sR0FBR0UsT0FBT0MsTUFBTSxDQUN6QyxJQUFJLENBQUNyQixlQUFlLENBQUNrQixNQUFNLElBQUlFLFVBQVVEO0FBRTdDO0FBRUEsVUFBVTtBQUVWeEIsSUFBSU8sU0FBUyxDQUFDb0IsT0FBTyxHQUFHLFNBQVVDLEtBQUssRUFBRUMsR0FBRztJQUMxQyxJQUFJTixPQUFPTyxNQUFNckI7SUFDakIsSUFBS2MsUUFBUSxJQUFJLENBQUNwQixpQkFBaUIsRUFBRTJCLE9BQU9GLE9BQU9MLFNBQVNPLE9BQU9ELEtBQUtDLE9BQVE7UUFDOUUsSUFBS3JCLFdBQVcsSUFBSSxDQUFDUixvQkFBb0IsRUFBRVEsV0FBVyxLQUFLQSxhQUFhLEVBQUc7WUFDekUsSUFBSSxRQUFTQSxZQUNOLElBQUksQ0FBQ1AsbUJBQW1CLENBQUNPLFNBQVMsQ0FBQ3NCLElBQUksQ0FBQyxJQUFJLEVBQUVELE1BQU1QLE9BQU9kLFdBQVc7Z0JBQUU7WUFBTztRQUN4RjtRQUVBLElBQUksQ0FBQ0gsV0FBVyxDQUFDd0IsTUFBTVAsT0FBT2Q7UUFFOUIsSUFBSUEsYUFBYSxLQUFLO1lBQUU7UUFBTztRQUMvQmMsUUFBUSxJQUFJLENBQUNsQixlQUFlLENBQUNrQixNQUFNLENBQUNkLFNBQVMsSUFBSTtJQUNuRDtJQUNBLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ0wsaUJBQWlCLENBQUNtQixNQUFNO0FBQ3hDO0FBRUFTLE9BQU9DLE9BQU8sR0FBR2pDLEtBRWpCLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC1tdWx0aW1kLXRhYmxlL2xpYi9kZmEuanM/YmM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIERGQSgpIHtcbiAgLy8gYWxwaGFiZXRzIGFyZSBlbmNvZGVkIGJ5IG51bWJlcnMgaW4gMTZeTiBmb3JtLCBwcmVzZW50aW5nIGl0cyBwcmVjZWRlbmNlXG4gIHRoaXMuX19oaWdoZXN0X2FscGhhYmV0X18gPSAweDA7XG4gIHRoaXMuX19tYXRjaF9hbHBoYWJldHNfXyA9IHt9O1xuICAvLyBzdGF0ZXMgYXJlIHVuaW9uIChiaXR3aXNlIE9SKSBvZiBpdHMgYWNjZXB0ZWQgYWxwaGFiZXRzXG4gIHRoaXMuX19pbml0aWFsX3N0YXRlX18gPSAweDA7XG4gIHRoaXMuX19hY2NlcHRfc3RhdGVzX18gPSB7fTtcbiAgLy8gdHJhbnNpdGlvbnMgYXJlIGluIHRoZSBmb3JtOiB7cHJldl9zdGF0ZToge2FscGhhYmV0OiBuZXh0X3N0YXRlfX1cbiAgdGhpcy5fX3RyYW5zaXRpb25zX18gPSB7fTtcbiAgLy8gYWN0aW9ucyB0YWtlIHR3byBwYXJhbWV0ZXJzOiBzdGVwIChsaW5lIG51bWJlciksIHByZXZfc3RhdGUgYW5kIGFscGhhYmV0XG4gIHRoaXMuX19hY3Rpb25zX18gPSB7fTtcbn1cblxuLy8gc2V0dGVyc1xuXG5ERkEucHJvdG90eXBlLnNldF9oaWdoZXN0X2FscGhhYmV0ID0gZnVuY3Rpb24gKGFscGhhYmV0KSB7XG4gIHRoaXMuX19oaWdoZXN0X2FscGhhYmV0X18gPSBhbHBoYWJldDtcbn07XG5cbkRGQS5wcm90b3R5cGUuc2V0X21hdGNoX2FscGhhYmV0cyA9IGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gIHRoaXMuX19tYXRjaF9hbHBoYWJldHNfXyA9IG1hdGNoZXM7XG59O1xuXG5ERkEucHJvdG90eXBlLnNldF9pbml0aWFsX3N0YXRlID0gZnVuY3Rpb24gKGluaXRpYWwpIHtcbiAgdGhpcy5fX2luaXRpYWxfc3RhdGVfXyA9IGluaXRpYWw7XG59O1xuXG5ERkEucHJvdG90eXBlLnNldF9hY2NlcHRfc3RhdGVzID0gZnVuY3Rpb24gKGFjY2VwdHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fX2FjY2VwdF9zdGF0ZXNfX1thY2NlcHRzW2ldXSA9IHRydWU7XG4gIH1cbn07XG5cbkRGQS5wcm90b3R5cGUuc2V0X3RyYW5zaXRpb25zID0gZnVuY3Rpb24gKHRyYW5zaXRpb25zKSB7XG4gIHRoaXMuX190cmFuc2l0aW9uc19fID0gdHJhbnNpdGlvbnM7XG59O1xuXG5ERkEucHJvdG90eXBlLnNldF9hY3Rpb25zID0gZnVuY3Rpb24gKGFjdGlvbnMpIHtcbiAgdGhpcy5fX2FjdGlvbnNfXyA9IGFjdGlvbnM7XG59O1xuXG5ERkEucHJvdG90eXBlLnVwZGF0ZV90cmFuc2l0aW9uID0gZnVuY3Rpb24gKHN0YXRlLCBhbHBoYWJldHMpIHtcbiAgdGhpcy5fX3RyYW5zaXRpb25zX19bc3RhdGVdID0gT2JqZWN0LmFzc2lnbihcbiAgICB0aGlzLl9fdHJhbnNpdGlvbnNfX1tzdGF0ZV0gfHwgT2JqZWN0KCksIGFscGhhYmV0c1xuICApO1xufTtcblxuLy8gbWV0aG9kc1xuXG5ERkEucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgc3RhdGUsIHN0ZXAsIGFscGhhYmV0O1xuICBmb3IgKHN0YXRlID0gdGhpcy5fX2luaXRpYWxfc3RhdGVfXywgc3RlcCA9IHN0YXJ0OyBzdGF0ZSAmJiBzdGVwIDwgZW5kOyBzdGVwKyspIHtcbiAgICBmb3IgKGFscGhhYmV0ID0gdGhpcy5fX2hpZ2hlc3RfYWxwaGFiZXRfXzsgYWxwaGFiZXQgPiAweDA7IGFscGhhYmV0ID4+PSA0KSB7XG4gICAgICBpZiAoKHN0YXRlICYgYWxwaGFiZXQpXG4gICAgICAgICAgJiYgdGhpcy5fX21hdGNoX2FscGhhYmV0c19fW2FscGhhYmV0XS5jYWxsKHRoaXMsIHN0ZXAsIHN0YXRlLCBhbHBoYWJldCkpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICB0aGlzLl9fYWN0aW9uc19fKHN0ZXAsIHN0YXRlLCBhbHBoYWJldCk7XG5cbiAgICBpZiAoYWxwaGFiZXQgPT09IDB4MCkgeyBicmVhazsgfVxuICAgIHN0YXRlID0gdGhpcy5fX3RyYW5zaXRpb25zX19bc3RhdGVdW2FscGhhYmV0XSB8fCAweDA7XG4gIH1cbiAgcmV0dXJuICEhdGhpcy5fX2FjY2VwdF9zdGF0ZXNfX1tzdGF0ZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERGQTtcblxuLyogdmltOiBzZXQgdHM9MiBzdz0yIGV0OiAqL1xuIl0sIm5hbWVzIjpbIkRGQSIsIl9faGlnaGVzdF9hbHBoYWJldF9fIiwiX19tYXRjaF9hbHBoYWJldHNfXyIsIl9faW5pdGlhbF9zdGF0ZV9fIiwiX19hY2NlcHRfc3RhdGVzX18iLCJfX3RyYW5zaXRpb25zX18iLCJfX2FjdGlvbnNfXyIsInByb3RvdHlwZSIsInNldF9oaWdoZXN0X2FscGhhYmV0IiwiYWxwaGFiZXQiLCJzZXRfbWF0Y2hfYWxwaGFiZXRzIiwibWF0Y2hlcyIsInNldF9pbml0aWFsX3N0YXRlIiwiaW5pdGlhbCIsInNldF9hY2NlcHRfc3RhdGVzIiwiYWNjZXB0cyIsImkiLCJsZW5ndGgiLCJzZXRfdHJhbnNpdGlvbnMiLCJ0cmFuc2l0aW9ucyIsInNldF9hY3Rpb25zIiwiYWN0aW9ucyIsInVwZGF0ZV90cmFuc2l0aW9uIiwic3RhdGUiLCJhbHBoYWJldHMiLCJPYmplY3QiLCJhc3NpZ24iLCJleGVjdXRlIiwic3RhcnQiLCJlbmQiLCJzdGVwIiwiY2FsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/markdown-it-multimd-table/lib/dfa.js\n");

/***/ })

};
;