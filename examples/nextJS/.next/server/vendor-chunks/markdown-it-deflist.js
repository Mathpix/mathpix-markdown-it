"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/markdown-it-deflist";
exports.ids = ["vendor-chunks/markdown-it-deflist"];
exports.modules = {

/***/ "(ssr)/./node_modules/markdown-it-deflist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/markdown-it-deflist/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// Process definition lists\n//\n\nmodule.exports = function deflist_plugin(md) {\n    var isSpace = md.utils.isSpace;\n    // Search `[:~][\\n ]`, returns next pos after marker on success\n    // or -1 on fail.\n    function skipMarker(state, line) {\n        var pos, marker, start = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];\n        if (start >= max) {\n            return -1;\n        }\n        // Check bullet\n        marker = state.src.charCodeAt(start++);\n        if (marker !== 0x7E /* ~ */  && marker !== 0x3A /* : */ ) {\n            return -1;\n        }\n        pos = state.skipSpaces(start);\n        // require space after \":\"\n        if (start === pos) {\n            return -1;\n        }\n        // no empty definitions, e.g. \"  : \"\n        if (pos >= max) {\n            return -1;\n        }\n        return start;\n    }\n    function markTightParagraphs(state, idx) {\n        var i, l, level = state.level + 2;\n        for(i = idx + 2, l = state.tokens.length - 2; i < l; i++){\n            if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\n                state.tokens[i + 2].hidden = true;\n                state.tokens[i].hidden = true;\n                i += 2;\n            }\n        }\n    }\n    function deflist(state, startLine, endLine, silent) {\n        var ch, contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, max, nextLine, offset, oldDDIndent, oldIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, prevEmptyEnd, tight, token;\n        if (silent) {\n            // quirk: validation mode validates a dd block only, not a whole deflist\n            if (state.ddIndent < 0) {\n                return false;\n            }\n            return skipMarker(state, startLine) >= 0;\n        }\n        nextLine = startLine + 1;\n        if (nextLine >= endLine) {\n            return false;\n        }\n        if (state.isEmpty(nextLine)) {\n            nextLine++;\n            if (nextLine >= endLine) {\n                return false;\n            }\n        }\n        if (state.sCount[nextLine] < state.blkIndent) {\n            return false;\n        }\n        contentStart = skipMarker(state, nextLine);\n        if (contentStart < 0) {\n            return false;\n        }\n        // Start list\n        listTokIdx = state.tokens.length;\n        tight = true;\n        token = state.push(\"dl_open\", \"dl\", 1);\n        token.map = listLines = [\n            startLine,\n            0\n        ];\n        //\n        // Iterate list items\n        //\n        dtLine = startLine;\n        ddLine = nextLine;\n        // One definition list can contain multiple DTs,\n        // and one DT can be followed by multiple DDs.\n        //\n        // Thus, there is two loops here, and label is\n        // needed to break out of the second one\n        //\n        /*eslint no-labels:0,block-scoped-var:0*/ OUTER: for(;;){\n            prevEmptyEnd = false;\n            token = state.push(\"dt_open\", \"dt\", 1);\n            token.map = [\n                dtLine,\n                dtLine\n            ];\n            token = state.push(\"inline\", \"\", 0);\n            token.map = [\n                dtLine,\n                dtLine\n            ];\n            token.content = state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim();\n            token.children = [];\n            token = state.push(\"dt_close\", \"dt\", -1);\n            for(;;){\n                token = state.push(\"dd_open\", \"dd\", 1);\n                token.map = itemLines = [\n                    nextLine,\n                    0\n                ];\n                pos = contentStart;\n                max = state.eMarks[ddLine];\n                offset = state.sCount[ddLine] + contentStart - (state.bMarks[ddLine] + state.tShift[ddLine]);\n                while(pos < max){\n                    ch = state.src.charCodeAt(pos);\n                    if (isSpace(ch)) {\n                        if (ch === 0x09) {\n                            offset += 4 - offset % 4;\n                        } else {\n                            offset++;\n                        }\n                    } else {\n                        break;\n                    }\n                    pos++;\n                }\n                contentStart = pos;\n                oldTight = state.tight;\n                oldDDIndent = state.ddIndent;\n                oldIndent = state.blkIndent;\n                oldTShift = state.tShift[ddLine];\n                oldSCount = state.sCount[ddLine];\n                oldParentType = state.parentType;\n                state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n                state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n                state.sCount[ddLine] = offset;\n                state.tight = true;\n                state.parentType = \"deflist\";\n                state.md.block.tokenize(state, ddLine, endLine, true);\n                // If any of list item is tight, mark list as tight\n                if (!state.tight || prevEmptyEnd) {\n                    tight = false;\n                }\n                // Item become loose if finish with empty line,\n                // but we should filter last element, because it means list finish\n                prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n                state.tShift[ddLine] = oldTShift;\n                state.sCount[ddLine] = oldSCount;\n                state.tight = oldTight;\n                state.parentType = oldParentType;\n                state.blkIndent = oldIndent;\n                state.ddIndent = oldDDIndent;\n                token = state.push(\"dd_close\", \"dd\", -1);\n                itemLines[1] = nextLine = state.line;\n                if (nextLine >= endLine) {\n                    break OUTER;\n                }\n                if (state.sCount[nextLine] < state.blkIndent) {\n                    break OUTER;\n                }\n                contentStart = skipMarker(state, nextLine);\n                if (contentStart < 0) {\n                    break;\n                }\n                ddLine = nextLine;\n            // go to the next loop iteration:\n            // insert DD tag and repeat checking\n            }\n            if (nextLine >= endLine) {\n                break;\n            }\n            dtLine = nextLine;\n            if (state.isEmpty(dtLine)) {\n                break;\n            }\n            if (state.sCount[dtLine] < state.blkIndent) {\n                break;\n            }\n            ddLine = dtLine + 1;\n            if (ddLine >= endLine) {\n                break;\n            }\n            if (state.isEmpty(ddLine)) {\n                ddLine++;\n            }\n            if (ddLine >= endLine) {\n                break;\n            }\n            if (state.sCount[ddLine] < state.blkIndent) {\n                break;\n            }\n            contentStart = skipMarker(state, ddLine);\n            if (contentStart < 0) {\n                break;\n            }\n        // go to the next loop iteration:\n        // insert DT and DD tags and repeat checking\n        }\n        // Finilize list\n        token = state.push(\"dl_close\", \"dl\", -1);\n        listLines[1] = nextLine;\n        state.line = nextLine;\n        // mark paragraphs tight if needed\n        if (tight) {\n            markTightParagraphs(state, listTokIdx);\n        }\n        return true;\n    }\n    md.block.ruler.before(\"paragraph\", \"deflist\", deflist, {\n        alt: [\n            \"paragraph\",\n            \"reference\",\n            \"blockquote\"\n        ]\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtZGVmbGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkI7QUFDM0IsRUFBRTtBQUNGO0FBR0FBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxlQUFlQyxFQUFFO0lBQ3pDLElBQUlDLFVBQVVELEdBQUdFLEtBQUssQ0FBQ0QsT0FBTztJQUU5QiwrREFBK0Q7SUFDL0QsaUJBQWlCO0lBQ2pCLFNBQVNFLFdBQVdDLEtBQUssRUFBRUMsSUFBSTtRQUM3QixJQUFJQyxLQUFLQyxRQUNMQyxRQUFRSixNQUFNSyxNQUFNLENBQUNKLEtBQUssR0FBR0QsTUFBTU0sTUFBTSxDQUFDTCxLQUFLLEVBQy9DTSxNQUFNUCxNQUFNUSxNQUFNLENBQUNQLEtBQUs7UUFFNUIsSUFBSUcsU0FBU0csS0FBSztZQUFFLE9BQU8sQ0FBQztRQUFHO1FBRS9CLGVBQWU7UUFDZkosU0FBU0gsTUFBTVMsR0FBRyxDQUFDQyxVQUFVLENBQUNOO1FBQzlCLElBQUlELFdBQVcsS0FBSSxLQUFLLE9BQU1BLFdBQVcsS0FBSSxLQUFLLEtBQUk7WUFBRSxPQUFPLENBQUM7UUFBRztRQUVuRUQsTUFBTUYsTUFBTVcsVUFBVSxDQUFDUDtRQUV2QiwwQkFBMEI7UUFDMUIsSUFBSUEsVUFBVUYsS0FBSztZQUFFLE9BQU8sQ0FBQztRQUFHO1FBRWhDLG9DQUFvQztRQUNwQyxJQUFJQSxPQUFPSyxLQUFLO1lBQUUsT0FBTyxDQUFDO1FBQUc7UUFFN0IsT0FBT0g7SUFDVDtJQUVBLFNBQVNRLG9CQUFvQlosS0FBSyxFQUFFYSxHQUFHO1FBQ3JDLElBQUlDLEdBQUdDLEdBQ0hDLFFBQVFoQixNQUFNZ0IsS0FBSyxHQUFHO1FBRTFCLElBQUtGLElBQUlELE1BQU0sR0FBR0UsSUFBSWYsTUFBTWlCLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHLEdBQUdKLElBQUlDLEdBQUdELElBQUs7WUFDekQsSUFBSWQsTUFBTWlCLE1BQU0sQ0FBQ0gsRUFBRSxDQUFDRSxLQUFLLEtBQUtBLFNBQVNoQixNQUFNaUIsTUFBTSxDQUFDSCxFQUFFLENBQUNLLElBQUksS0FBSyxrQkFBa0I7Z0JBQ2hGbkIsTUFBTWlCLE1BQU0sQ0FBQ0gsSUFBSSxFQUFFLENBQUNNLE1BQU0sR0FBRztnQkFDN0JwQixNQUFNaUIsTUFBTSxDQUFDSCxFQUFFLENBQUNNLE1BQU0sR0FBRztnQkFDekJOLEtBQUs7WUFDUDtRQUNGO0lBQ0Y7SUFFQSxTQUFTTyxRQUFRckIsS0FBSyxFQUFFc0IsU0FBUyxFQUFFQyxPQUFPLEVBQUVDLE1BQU07UUFDaEQsSUFBSUMsSUFDQUMsY0FDQUMsUUFDQUMsUUFDQUMsV0FDQUMsV0FDQUMsWUFDQXhCLEtBQ0F5QixVQUNBQyxRQUNBQyxhQUNBQyxXQUNBQyxlQUNBQyxXQUNBQyxXQUNBQyxVQUNBckMsS0FDQXNDLGNBQ0FDLE9BQ0FDO1FBRUosSUFBSWxCLFFBQVE7WUFDVix3RUFBd0U7WUFDeEUsSUFBSXhCLE1BQU0yQyxRQUFRLEdBQUcsR0FBRztnQkFBRSxPQUFPO1lBQU87WUFDeEMsT0FBTzVDLFdBQVdDLE9BQU9zQixjQUFjO1FBQ3pDO1FBRUFVLFdBQVdWLFlBQVk7UUFDdkIsSUFBSVUsWUFBWVQsU0FBUztZQUFFLE9BQU87UUFBTztRQUV6QyxJQUFJdkIsTUFBTTRDLE9BQU8sQ0FBQ1osV0FBVztZQUMzQkE7WUFDQSxJQUFJQSxZQUFZVCxTQUFTO2dCQUFFLE9BQU87WUFBTztRQUMzQztRQUVBLElBQUl2QixNQUFNNkMsTUFBTSxDQUFDYixTQUFTLEdBQUdoQyxNQUFNOEMsU0FBUyxFQUFFO1lBQUUsT0FBTztRQUFPO1FBQzlEcEIsZUFBZTNCLFdBQVdDLE9BQU9nQztRQUNqQyxJQUFJTixlQUFlLEdBQUc7WUFBRSxPQUFPO1FBQU87UUFFdEMsYUFBYTtRQUNiSyxhQUFhL0IsTUFBTWlCLE1BQU0sQ0FBQ0MsTUFBTTtRQUNoQ3VCLFFBQVE7UUFFUkMsUUFBWTFDLE1BQU0rQyxJQUFJLENBQUMsV0FBVyxNQUFNO1FBQ3hDTCxNQUFNTSxHQUFHLEdBQUdsQixZQUFZO1lBQUVSO1lBQVc7U0FBRztRQUV4QyxFQUFFO1FBQ0YscUJBQXFCO1FBQ3JCLEVBQUU7UUFFRk0sU0FBU047UUFDVEssU0FBU0s7UUFFVCxnREFBZ0Q7UUFDaEQsOENBQThDO1FBQzlDLEVBQUU7UUFDRiw4Q0FBOEM7UUFDOUMsd0NBQXdDO1FBQ3hDLEVBQUU7UUFDRix1Q0FBdUMsR0FDdkNpQixPQUNBLE9BQVM7WUFDUFQsZUFBZTtZQUVmRSxRQUFpQjFDLE1BQU0rQyxJQUFJLENBQUMsV0FBVyxNQUFNO1lBQzdDTCxNQUFNTSxHQUFHLEdBQVE7Z0JBQUVwQjtnQkFBUUE7YUFBUTtZQUVuQ2MsUUFBaUIxQyxNQUFNK0MsSUFBSSxDQUFDLFVBQVUsSUFBSTtZQUMxQ0wsTUFBTU0sR0FBRyxHQUFRO2dCQUFFcEI7Z0JBQVFBO2FBQVE7WUFDbkNjLE1BQU1RLE9BQU8sR0FBSWxELE1BQU1tRCxRQUFRLENBQUN2QixRQUFRQSxTQUFTLEdBQUc1QixNQUFNOEMsU0FBUyxFQUFFLE9BQU9NLElBQUk7WUFDaEZWLE1BQU1XLFFBQVEsR0FBRyxFQUFFO1lBRW5CWCxRQUFpQjFDLE1BQU0rQyxJQUFJLENBQUMsWUFBWSxNQUFNLENBQUM7WUFFL0MsT0FBUztnQkFDUEwsUUFBWTFDLE1BQU0rQyxJQUFJLENBQUMsV0FBVyxNQUFNO2dCQUN4Q0wsTUFBTU0sR0FBRyxHQUFHbkIsWUFBWTtvQkFBRUc7b0JBQVU7aUJBQUc7Z0JBRXZDOUIsTUFBTXdCO2dCQUNObkIsTUFBTVAsTUFBTVEsTUFBTSxDQUFDbUIsT0FBTztnQkFDMUJNLFNBQVNqQyxNQUFNNkMsTUFBTSxDQUFDbEIsT0FBTyxHQUFHRCxlQUFnQjFCLENBQUFBLE1BQU1LLE1BQU0sQ0FBQ3NCLE9BQU8sR0FBRzNCLE1BQU1NLE1BQU0sQ0FBQ3FCLE9BQU87Z0JBRTNGLE1BQU96QixNQUFNSyxJQUFLO29CQUNoQmtCLEtBQUt6QixNQUFNUyxHQUFHLENBQUNDLFVBQVUsQ0FBQ1I7b0JBRTFCLElBQUlMLFFBQVE0QixLQUFLO3dCQUNmLElBQUlBLE9BQU8sTUFBTTs0QkFDZlEsVUFBVSxJQUFJQSxTQUFTO3dCQUN6QixPQUFPOzRCQUNMQTt3QkFDRjtvQkFDRixPQUFPO3dCQUNMO29CQUNGO29CQUVBL0I7Z0JBQ0Y7Z0JBRUF3QixlQUFleEI7Z0JBRWZxQyxXQUFXdkMsTUFBTXlDLEtBQUs7Z0JBQ3RCUCxjQUFjbEMsTUFBTTJDLFFBQVE7Z0JBQzVCUixZQUFZbkMsTUFBTThDLFNBQVM7Z0JBQzNCUixZQUFZdEMsTUFBTU0sTUFBTSxDQUFDcUIsT0FBTztnQkFDaENVLFlBQVlyQyxNQUFNNkMsTUFBTSxDQUFDbEIsT0FBTztnQkFDaENTLGdCQUFnQnBDLE1BQU1zRCxVQUFVO2dCQUNoQ3RELE1BQU04QyxTQUFTLEdBQUc5QyxNQUFNMkMsUUFBUSxHQUFHM0MsTUFBTTZDLE1BQU0sQ0FBQ2xCLE9BQU8sR0FBRztnQkFDMUQzQixNQUFNTSxNQUFNLENBQUNxQixPQUFPLEdBQUdELGVBQWUxQixNQUFNSyxNQUFNLENBQUNzQixPQUFPO2dCQUMxRDNCLE1BQU02QyxNQUFNLENBQUNsQixPQUFPLEdBQUdNO2dCQUN2QmpDLE1BQU15QyxLQUFLLEdBQUc7Z0JBQ2R6QyxNQUFNc0QsVUFBVSxHQUFHO2dCQUVuQnRELE1BQU1KLEVBQUUsQ0FBQzJELEtBQUssQ0FBQ0MsUUFBUSxDQUFDeEQsT0FBTzJCLFFBQVFKLFNBQVM7Z0JBRWhELG1EQUFtRDtnQkFDbkQsSUFBSSxDQUFDdkIsTUFBTXlDLEtBQUssSUFBSUQsY0FBYztvQkFDaENDLFFBQVE7Z0JBQ1Y7Z0JBQ0EsK0NBQStDO2dCQUMvQyxrRUFBa0U7Z0JBQ2xFRCxlQUFlLE1BQU92QyxJQUFJLEdBQUcwQixTQUFVLEtBQUszQixNQUFNNEMsT0FBTyxDQUFDNUMsTUFBTUMsSUFBSSxHQUFHO2dCQUV2RUQsTUFBTU0sTUFBTSxDQUFDcUIsT0FBTyxHQUFHVztnQkFDdkJ0QyxNQUFNNkMsTUFBTSxDQUFDbEIsT0FBTyxHQUFHVTtnQkFDdkJyQyxNQUFNeUMsS0FBSyxHQUFHRjtnQkFDZHZDLE1BQU1zRCxVQUFVLEdBQUdsQjtnQkFDbkJwQyxNQUFNOEMsU0FBUyxHQUFHWDtnQkFDbEJuQyxNQUFNMkMsUUFBUSxHQUFHVDtnQkFFakJRLFFBQVExQyxNQUFNK0MsSUFBSSxDQUFDLFlBQVksTUFBTSxDQUFDO2dCQUV0Q2xCLFNBQVMsQ0FBQyxFQUFFLEdBQUdHLFdBQVdoQyxNQUFNQyxJQUFJO2dCQUVwQyxJQUFJK0IsWUFBWVQsU0FBUztvQkFBRSxNQUFNMEI7Z0JBQU87Z0JBRXhDLElBQUlqRCxNQUFNNkMsTUFBTSxDQUFDYixTQUFTLEdBQUdoQyxNQUFNOEMsU0FBUyxFQUFFO29CQUFFLE1BQU1HO2dCQUFPO2dCQUM3RHZCLGVBQWUzQixXQUFXQyxPQUFPZ0M7Z0JBQ2pDLElBQUlOLGVBQWUsR0FBRztvQkFBRTtnQkFBTztnQkFFL0JDLFNBQVNLO1lBRVQsaUNBQWlDO1lBQ2pDLG9DQUFvQztZQUN0QztZQUVBLElBQUlBLFlBQVlULFNBQVM7Z0JBQUU7WUFBTztZQUNsQ0ssU0FBU0k7WUFFVCxJQUFJaEMsTUFBTTRDLE9BQU8sQ0FBQ2hCLFNBQVM7Z0JBQUU7WUFBTztZQUNwQyxJQUFJNUIsTUFBTTZDLE1BQU0sQ0FBQ2pCLE9BQU8sR0FBRzVCLE1BQU04QyxTQUFTLEVBQUU7Z0JBQUU7WUFBTztZQUVyRG5CLFNBQVNDLFNBQVM7WUFDbEIsSUFBSUQsVUFBVUosU0FBUztnQkFBRTtZQUFPO1lBQ2hDLElBQUl2QixNQUFNNEMsT0FBTyxDQUFDakIsU0FBUztnQkFBRUE7WUFBVTtZQUN2QyxJQUFJQSxVQUFVSixTQUFTO2dCQUFFO1lBQU87WUFFaEMsSUFBSXZCLE1BQU02QyxNQUFNLENBQUNsQixPQUFPLEdBQUczQixNQUFNOEMsU0FBUyxFQUFFO2dCQUFFO1lBQU87WUFDckRwQixlQUFlM0IsV0FBV0MsT0FBTzJCO1lBQ2pDLElBQUlELGVBQWUsR0FBRztnQkFBRTtZQUFPO1FBRS9CLGlDQUFpQztRQUNqQyw0Q0FBNEM7UUFDOUM7UUFFQSxnQkFBZ0I7UUFDaEJnQixRQUFRMUMsTUFBTStDLElBQUksQ0FBQyxZQUFZLE1BQU0sQ0FBQztRQUV0Q2pCLFNBQVMsQ0FBQyxFQUFFLEdBQUdFO1FBRWZoQyxNQUFNQyxJQUFJLEdBQUcrQjtRQUViLGtDQUFrQztRQUNsQyxJQUFJUyxPQUFPO1lBQ1Q3QixvQkFBb0JaLE9BQU8rQjtRQUM3QjtRQUVBLE9BQU87SUFDVDtJQUdBbkMsR0FBRzJELEtBQUssQ0FBQ0UsS0FBSyxDQUFDQyxNQUFNLENBQUMsYUFBYSxXQUFXckMsU0FBUztRQUFFc0MsS0FBSztZQUFFO1lBQWE7WUFBYTtTQUFjO0lBQUM7QUFDM0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQtZGVmbGlzdC9pbmRleC5qcz83YTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2Nlc3MgZGVmaW5pdGlvbiBsaXN0c1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmxpc3RfcGx1Z2luKG1kKSB7XG4gIHZhciBpc1NwYWNlID0gbWQudXRpbHMuaXNTcGFjZTtcblxuICAvLyBTZWFyY2ggYFs6fl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4gIC8vIG9yIC0xIG9uIGZhaWwuXG4gIGZ1bmN0aW9uIHNraXBNYXJrZXIoc3RhdGUsIGxpbmUpIHtcbiAgICB2YXIgcG9zLCBtYXJrZXIsXG4gICAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUudFNoaWZ0W2xpbmVdLFxuICAgICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbGluZV07XG5cbiAgICBpZiAoc3RhcnQgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgLy8gQ2hlY2sgYnVsbGV0XG4gICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQrKyk7XG4gICAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8gJiYgbWFya2VyICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gLTE7IH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMoc3RhcnQpO1xuXG4gICAgLy8gcmVxdWlyZSBzcGFjZSBhZnRlciBcIjpcIlxuICAgIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiAtMTsgfVxuXG4gICAgLy8gbm8gZW1wdHkgZGVmaW5pdGlvbnMsIGUuZy4gXCIgIDogXCJcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICAgIHJldHVybiBzdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICAgIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgdmFyIGNoLFxuICAgICAgICBjb250ZW50U3RhcnQsXG4gICAgICAgIGRkTGluZSxcbiAgICAgICAgZHRMaW5lLFxuICAgICAgICBpdGVtTGluZXMsXG4gICAgICAgIGxpc3RMaW5lcyxcbiAgICAgICAgbGlzdFRva0lkeCxcbiAgICAgICAgbWF4LFxuICAgICAgICBuZXh0TGluZSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvbGREREluZGVudCxcbiAgICAgICAgb2xkSW5kZW50LFxuICAgICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgICBvbGRTQ291bnQsXG4gICAgICAgIG9sZFRTaGlmdCxcbiAgICAgICAgb2xkVGlnaHQsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcHJldkVtcHR5RW5kLFxuICAgICAgICB0aWdodCxcbiAgICAgICAgdG9rZW47XG5cbiAgICBpZiAoc2lsZW50KSB7XG4gICAgICAvLyBxdWlyazogdmFsaWRhdGlvbiBtb2RlIHZhbGlkYXRlcyBhIGRkIGJsb2NrIG9ubHksIG5vdCBhIHdob2xlIGRlZmxpc3RcbiAgICAgIGlmIChzdGF0ZS5kZEluZGVudCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICByZXR1cm4gc2tpcE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSA+PSAwO1xuICAgIH1cblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNvbnRlbnRTdGFydCA9IHNraXBNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICBpZiAoY29udGVudFN0YXJ0IDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFN0YXJ0IGxpc3RcbiAgICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcbiAgICB0aWdodCA9IHRydWU7XG5cbiAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCdkbF9vcGVuJywgJ2RsJywgMSk7XG4gICAgdG9rZW4ubWFwID0gbGlzdExpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICAgIC8vXG4gICAgLy8gSXRlcmF0ZSBsaXN0IGl0ZW1zXG4gICAgLy9cblxuICAgIGR0TGluZSA9IHN0YXJ0TGluZTtcbiAgICBkZExpbmUgPSBuZXh0TGluZTtcblxuICAgIC8vIE9uZSBkZWZpbml0aW9uIGxpc3QgY2FuIGNvbnRhaW4gbXVsdGlwbGUgRFRzLFxuICAgIC8vIGFuZCBvbmUgRFQgY2FuIGJlIGZvbGxvd2VkIGJ5IG11bHRpcGxlIEREcy5cbiAgICAvL1xuICAgIC8vIFRodXMsIHRoZXJlIGlzIHR3byBsb29wcyBoZXJlLCBhbmQgbGFiZWwgaXNcbiAgICAvLyBuZWVkZWQgdG8gYnJlYWsgb3V0IG9mIHRoZSBzZWNvbmQgb25lXG4gICAgLy9cbiAgICAvKmVzbGludCBuby1sYWJlbHM6MCxibG9jay1zY29wZWQtdmFyOjAqL1xuICAgIE9VVEVSOlxuICAgIGZvciAoOzspIHtcbiAgICAgIHByZXZFbXB0eUVuZCA9IGZhbHNlO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2R0X29wZW4nLCAnZHQnLCAxKTtcbiAgICAgIHRva2VuLm1hcCAgICAgID0gWyBkdExpbmUsIGR0TGluZSBdO1xuXG4gICAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICAgIHRva2VuLm1hcCAgICAgID0gWyBkdExpbmUsIGR0TGluZSBdO1xuICAgICAgdG9rZW4uY29udGVudCAgPSBzdGF0ZS5nZXRMaW5lcyhkdExpbmUsIGR0TGluZSArIDEsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnZHRfY2xvc2UnLCAnZHQnLCAtMSk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgnZGRfb3BlbicsICdkZCcsIDEpO1xuICAgICAgICB0b2tlbi5tYXAgPSBpdGVtTGluZXMgPSBbIG5leHRMaW5lLCAwIF07XG5cbiAgICAgICAgcG9zID0gY29udGVudFN0YXJ0O1xuICAgICAgICBtYXggPSBzdGF0ZS5lTWFya3NbZGRMaW5lXTtcbiAgICAgICAgb2Zmc2V0ID0gc3RhdGUuc0NvdW50W2RkTGluZV0gKyBjb250ZW50U3RhcnQgLSAoc3RhdGUuYk1hcmtzW2RkTGluZV0gKyBzdGF0ZS50U2hpZnRbZGRMaW5lXSk7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRTdGFydCA9IHBvcztcblxuICAgICAgICBvbGRUaWdodCA9IHN0YXRlLnRpZ2h0O1xuICAgICAgICBvbGREREluZGVudCA9IHN0YXRlLmRkSW5kZW50O1xuICAgICAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICAgIG9sZFRTaGlmdCA9IHN0YXRlLnRTaGlmdFtkZExpbmVdO1xuICAgICAgICBvbGRTQ291bnQgPSBzdGF0ZS5zQ291bnRbZGRMaW5lXTtcbiAgICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICAgIHN0YXRlLmJsa0luZGVudCA9IHN0YXRlLmRkSW5kZW50ID0gc3RhdGUuc0NvdW50W2RkTGluZV0gKyAyO1xuICAgICAgICBzdGF0ZS50U2hpZnRbZGRMaW5lXSA9IGNvbnRlbnRTdGFydCAtIHN0YXRlLmJNYXJrc1tkZExpbmVdO1xuICAgICAgICBzdGF0ZS5zQ291bnRbZGRMaW5lXSA9IG9mZnNldDtcbiAgICAgICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gJ2RlZmxpc3QnO1xuXG4gICAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBkZExpbmUsIGVuZExpbmUsIHRydWUpO1xuXG4gICAgICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgICAgICBpZiAoIXN0YXRlLnRpZ2h0IHx8IHByZXZFbXB0eUVuZCkge1xuICAgICAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlbSBiZWNvbWUgbG9vc2UgaWYgZmluaXNoIHdpdGggZW1wdHkgbGluZSxcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gZGRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICAgICAgc3RhdGUudFNoaWZ0W2RkTGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgICAgIHN0YXRlLnNDb3VudFtkZExpbmVdID0gb2xkU0NvdW50O1xuICAgICAgICBzdGF0ZS50aWdodCA9IG9sZFRpZ2h0O1xuICAgICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgICAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuICAgICAgICBzdGF0ZS5kZEluZGVudCA9IG9sZERESW5kZW50O1xuXG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaCgnZGRfY2xvc2UnLCAnZGQnLCAtMSk7XG5cbiAgICAgICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrIE9VVEVSOyB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWsgT1VURVI7IH1cbiAgICAgICAgY29udGVudFN0YXJ0ID0gc2tpcE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgICBpZiAoY29udGVudFN0YXJ0IDwgMCkgeyBicmVhazsgfVxuXG4gICAgICAgIGRkTGluZSA9IG5leHRMaW5lO1xuXG4gICAgICAgIC8vIGdvIHRvIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uOlxuICAgICAgICAvLyBpbnNlcnQgREQgdGFnIGFuZCByZXBlYXQgY2hlY2tpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWs7IH1cbiAgICAgIGR0TGluZSA9IG5leHRMaW5lO1xuXG4gICAgICBpZiAoc3RhdGUuaXNFbXB0eShkdExpbmUpKSB7IGJyZWFrOyB9XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W2R0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgICAgZGRMaW5lID0gZHRMaW5lICsgMTtcbiAgICAgIGlmIChkZExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuICAgICAgaWYgKHN0YXRlLmlzRW1wdHkoZGRMaW5lKSkgeyBkZExpbmUrKzsgfVxuICAgICAgaWYgKGRkTGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbZGRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuICAgICAgY29udGVudFN0YXJ0ID0gc2tpcE1hcmtlcihzdGF0ZSwgZGRMaW5lKTtcbiAgICAgIGlmIChjb250ZW50U3RhcnQgPCAwKSB7IGJyZWFrOyB9XG5cbiAgICAgIC8vIGdvIHRvIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uOlxuICAgICAgLy8gaW5zZXJ0IERUIGFuZCBERCB0YWdzIGFuZCByZXBlYXQgY2hlY2tpbmdcbiAgICB9XG5cbiAgICAvLyBGaW5pbGl6ZSBsaXN0XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdkbF9jbG9zZScsICdkbCcsIC0xKTtcblxuICAgIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuXG4gICAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gICAgLy8gbWFyayBwYXJhZ3JhcGhzIHRpZ2h0IGlmIG5lZWRlZFxuICAgIGlmICh0aWdodCkge1xuICAgICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuXG4gIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZSgncGFyYWdyYXBoJywgJ2RlZmxpc3QnLCBkZWZsaXN0LCB7IGFsdDogWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIH0pO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZGVmbGlzdF9wbHVnaW4iLCJtZCIsImlzU3BhY2UiLCJ1dGlscyIsInNraXBNYXJrZXIiLCJzdGF0ZSIsImxpbmUiLCJwb3MiLCJtYXJrZXIiLCJzdGFydCIsImJNYXJrcyIsInRTaGlmdCIsIm1heCIsImVNYXJrcyIsInNyYyIsImNoYXJDb2RlQXQiLCJza2lwU3BhY2VzIiwibWFya1RpZ2h0UGFyYWdyYXBocyIsImlkeCIsImkiLCJsIiwibGV2ZWwiLCJ0b2tlbnMiLCJsZW5ndGgiLCJ0eXBlIiwiaGlkZGVuIiwiZGVmbGlzdCIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJzaWxlbnQiLCJjaCIsImNvbnRlbnRTdGFydCIsImRkTGluZSIsImR0TGluZSIsIml0ZW1MaW5lcyIsImxpc3RMaW5lcyIsImxpc3RUb2tJZHgiLCJuZXh0TGluZSIsIm9mZnNldCIsIm9sZERESW5kZW50Iiwib2xkSW5kZW50Iiwib2xkUGFyZW50VHlwZSIsIm9sZFNDb3VudCIsIm9sZFRTaGlmdCIsIm9sZFRpZ2h0IiwicHJldkVtcHR5RW5kIiwidGlnaHQiLCJ0b2tlbiIsImRkSW5kZW50IiwiaXNFbXB0eSIsInNDb3VudCIsImJsa0luZGVudCIsInB1c2giLCJtYXAiLCJPVVRFUiIsImNvbnRlbnQiLCJnZXRMaW5lcyIsInRyaW0iLCJjaGlsZHJlbiIsInBhcmVudFR5cGUiLCJibG9jayIsInRva2VuaXplIiwicnVsZXIiLCJiZWZvcmUiLCJhbHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/markdown-it-deflist/index.js\n");

/***/ })

};
;