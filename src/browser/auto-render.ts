import { MathJax } from "../mathjax";
import { loadSreAsync } from "../sre/sre-browser";
import {TAccessibility, TOutputMath} from "../mathpix-markdown-model";

const RE_TEX_DISPLAY_DOLLARS: RegExp = /^\$\$[\s\S]*\$\$$/;
const RE_TEX_DISPLAY_BRACKETS: RegExp = /^\\\[[\s\S]*\\\]$/;
const RE_TEX_INLINE_PARENS: RegExp = /^\\\([\s\S]*\\\)$/;
const RE_TEX_INLINE_DOLLAR: RegExp = /^\$[\s\S]*\$$/;
const RE_TEX_ENV_WHOLE: RegExp = /^\\begin\{[^}]+\}[\s\S]*\\end\{[^}]+\}$/;

export interface MathpixAccessibilityConfig {
  /** Expose MathJax assistive MathML for screen readers */
  assistive_mml?: boolean;
  /** Add aria-label speech string generated by SRE */
  include_speech?: boolean;
}

export interface MathpixRenderConfig {
  accessibility: MathpixAccessibilityConfig;
  outMath: TOutputMath;
  /** Container width used for layout metrics (cwidth) */
  width?: number;
}

const defaultConfig: MathpixRenderConfig = {
  accessibility: {
    assistive_mml: true,
    include_speech: true
  },
  outMath: {
    output_format: "svg",
    include_svg: true,
    include_asciimath: true,
    include_latex: true,
    include_mathml: true,
    include_mathml_word: true,
    include_smiles: true ,
    include_speech: true,
    include_table_markdown: true,
    include_tsv: true
  },
  width: 1200
};

type TypesetTarget =
  | { kind: 'tex'; tex: string; display: boolean }
  | { kind: 'mathml'; mathml: string; display: boolean };

type StripResult = { tex: string; display: boolean } | null;

/**
 * Returns true if the element appears to be already typeset by Mathpix/MathJax.
 * Used to prevent double-rendering during autorender passes.
 *
 * Heuristics:
 *  - Prefer an explicit marker attribute set by our renderer.
 *  - Otherwise detect common MathJax output containers/markers.
 */
const isAlreadyRenderedMath = (el: Element): boolean => {
  // Fast & explicit: our own marker.
  if (el.hasAttribute('data-mathpix-typeset')) return true;
  // Single DOM query for common MathJax output.
  const alreadyRenderedSelector = [
    'mjx-container',                 // MathJax v3
    'mjx-container[jax]',            // e.g. jax="SVG"
    'mjx-assistive-mml',             // assistive MathML node
    '[data-mjx-container]',          // some integrations add this attribute
    '.mjx-container',                // legacy / custom wrappers
    '.MathJax',                      // common class used by MathJax output
  ].join(',');
  return el.querySelector(alreadyRenderedSelector) !== null;
};

/**
 * Returns true if the element contains exactly one meaningful child node and it is a MathML <math> element.
 * Example accepted structure:
 *   <span class="math-block"><math xmlns="http://www.w3.org/1998/Math/MathML">...</math></span>
 */
const isOnlyMathMLElement = (el: HTMLElement): boolean => {
  const children = Array.from(el.childNodes).filter(
    (n) => !(n.nodeType === Node.TEXT_NODE && !(n.textContent ?? '').trim())
  );
  return children.length === 1 &&
    children[0].nodeType === Node.ELEMENT_NODE &&
    (children[0] as Element).tagName.toLowerCase() === 'math';
}

/**
 * Extracts the MathML markup from the given element and determines
 * whether it should be treated as display (block) math.
 *
 * Display mode is inferred from:
 *  - the MathML `display="block"` attribute, or
 *  - a wrapper element having the `math-block` CSS class.
 */
const getMathMLString = (el: HTMLElement): { mathml: string; display: boolean } => {
  const mathEl = el.querySelector('math') as Element;
  const displayAttr = mathEl?.getAttribute('display');
  const display = displayAttr === 'block' || el.classList.contains('math-block');
  return { mathml: mathEl.outerHTML, display };
}

/**
 * If the input string is entirely wrapped in a single pair of outer TeX math delimiters,
 * strips those outer delimiters and returns the inner TeX plus an inferred display mode.
 * Returns null if the input is not fully wrapped.
 */
const stripOuterMathDelimitersIfWhole = (raw: string): StripResult => {
  const text: string = (raw ?? '').trim();
  if (!text) return null;
  // $$...$$
  if (RE_TEX_DISPLAY_DOLLARS.test(text)) {
    return { tex: text.slice(2, -2).trim(), display: true };
  }
  // \[...\]
  if (RE_TEX_DISPLAY_BRACKETS.test(text)) {
    return { tex: text.slice(2, -2).trim(), display: true };
  }
  // \(...\)
  if (RE_TEX_INLINE_PARENS.test(text)) {
    return { tex: text.slice(2, -2).trim(), display: false };
  }
  // $...$ (but not $$...$$)
  if (RE_TEX_INLINE_DOLLAR.test(text) && !(text.startsWith('$$') && text.endsWith('$$'))) {
    return { tex: text.slice(1, -1).trim(), display: false };
  }
  // \begin{...}...\end{...} (whole string)
  if (RE_TEX_ENV_WHOLE.test(text)) {
    return { tex: text, display: true };
  }
  return null;
}

/**
 * Decides whether a given element should be typeset as math.
 * - If the element contains a single MathML node (<math>...</math>) -> returns a MathML target.
 * - If the element already contains rendered math (SVG/MathJax containers) -> returns null.
 * - If the element contains non-trivial child elements (except <br>) -> returns null.
 * - Otherwise, if its text is fully wrapped in TeX math delimiters -> returns a TeX target.
 */
const shouldTypesetNode = (el: HTMLElement): TypesetTarget | null => {
  // 0) Pure MathML input (render it)
  if (isOnlyMathMLElement(el)) {
    const { mathml, display } = getMathMLString(el);
    return {
      kind: 'mathml',
      mathml,
      display
    };
  }
  // 1) Already rendered (svg/mjx-container/etc.) -> skip
  if (isAlreadyRenderedMath(el)) {
    return null;
  }
  // 2) Contains child elements other than <br> -> skip
  const hasNonTrivialChildElements: boolean = Array.from(el.childNodes).some((node) => {
    if (node.nodeType !== Node.ELEMENT_NODE) return false;
    return (node as Element).tagName.toLowerCase() !== 'br';
  });
  if (hasNonTrivialChildElements) {
    return null;
  }
  // 3) Otherwise, check for fully-wrapped TeX delimiters
  const text: string = el.textContent ?? '';
  const match = stripOuterMathDelimitersIfWhole(text);
  if (!match) {
    return null;
  }
  return {
    kind: 'tex',
    tex: match.tex,
    display: match.display
  };
};

/**
 * Resolves accessibility feature flags from user config.
 * Default behavior: if config is missing, both flags are enabled.
 */
const resolveA11yFlags = (a11y: unknown): { assistiveMml: boolean; includeSpeech: boolean } => {
  const cfg = (a11y && typeof a11y === 'object') ? (a11y as any) : null;
  if (!cfg) {
    return { assistiveMml: true, includeSpeech: true };
  }
  return {
    // `undefined` -> true, only explicit `false` disables the feature
    assistiveMml: cfg.assistive_mml !== false,
    includeSpeech: cfg.include_speech !== false,
  };
};

/**
 * Builds MathJax accessibility options based on user config.
 * Returns `undefined` if all accessibility features are disabled.
 */
const buildAccessibilityOptions = async (a11y: unknown): Promise<TAccessibility | undefined> => {
  const { assistiveMml, includeSpeech } = resolveA11yFlags(a11y);
  // If all features are disabled, return undefined to avoid enabling a11y pipeline.
  if (!assistiveMml && !includeSpeech) {
    return undefined;
  }
  const opts: TAccessibility = {};
  if (assistiveMml) {
    opts.assistiveMml = true;
  }
  if (includeSpeech) {
    const sre = await loadSreAsync();
    if (sre) {
      opts.sre = sre;
    }
  }
  return opts;
}

/**
 * Replace element contents with rendered math HTML.
 * Note: this will remove existing child nodes inside `el` (but keeps the element itself).
 */
const setInnerHTML = (el: HTMLElement, html: string): void => {
  el.innerHTML = html;
}

/**
 * Typeset MathJax math inside a container element.
 * Searches for `.math-inline` and `.math-block`, detects whether each node contains pure MathML or TeX,
 * and replaces its inner HTML with MathJax output.
 */
export const renderMathInElement = async (
  container: HTMLElement,
  config?: Partial<MathpixRenderConfig>
): Promise<void> => {
  const cfg: Partial<MathpixRenderConfig> = config ?? {};
  const outMath: TOutputMath = cfg.outMath ?? {};
  // Collect candidates (we only typeset nodes that look like "raw math" input).
  const mathNodes = Array.from(
    container.querySelectorAll<HTMLElement>('.math-inline, .math-block')
  );
  // Build accessibility options once per render session (loading SRE can be async/expensive).
  const accessibility: TAccessibility = await buildAccessibilityOptions(cfg.accessibility);
  // Start a new "render session" so a11y ids (aria-labelledby) can be generated consistently.
  MathJax.beginRender();
  MathJax.Reset();
  for (const mathEl of mathNodes) {
    const target: TypesetTarget = shouldTypesetNode(mathEl);
    if (!target) continue;
    try {
      const metric = { cwidth: 1200 };
      const result = target.kind === 'mathml'
        ? MathJax.TypesetMathML(target.mathml, {
          display: target.display,
          metric,
          outMath,
          accessibility,
        })
        : MathJax.Typeset(target.tex, {
          display: target.display,
          metric,
          outMath,
          accessibility,
        });
      // Replace content with MathJax output.
      setInnerHTML(mathEl, result.html);
      // Mark as already typeset to avoid re-processing on future passes.
      mathEl.setAttribute('data-mathpix-typeset', 'true');
    } catch (err) {
      // Do not fail the whole render if one formula is broken.
      // Consider logging or attaching an error marker if you want debugging visibility.
      console.error('[renderMathInElement] Failed to typeset node:', err, mathEl);
    }
  }
}

/**
 * Returns true when running in a browser environment (not SSR / Node).
 */
const isBrowser = (): boolean => {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Read config from the global `window.MathpixRenderConfig` if provided,
 * otherwise fall back to `defaultConfig`.
 *
 * Note: we intentionally read config at execution time (not module init time)
 * so apps can set `window.MathpixRenderConfig` before DOMContentLoaded.
 */
const getGlobalConfig = (): MathpixRenderConfig => {
  return ((window as any).MathpixRenderConfig as MathpixRenderConfig) || defaultConfig;
}

/**
 * Auto-render math inside a root element (defaults to document.body).
 * This function is meant to be called once on page load.
 */
const autoRender = (): void => {
  // Prefer rendering inside a narrower scope if the integrator provides it.
  const config: MathpixRenderConfig = getGlobalConfig();
  renderMathInElement(document.body, config).catch((err) => {
    console.error('[MathpixRender] autoRender failed:', err);
  });
}

// Auto-render on DOMContentLoaded (browser only).
if (isBrowser()) {
  // If DOM isn't ready, wait once; otherwise run immediately.
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', autoRender, { once: true });
  } else {
    autoRender();
  }
  /**
   * Global API exposed for integrators (optional usage).
   * - `renderMathInElement`: manual rendering entry point
   */
  (window as any).MathpixRender = {
    renderMathInElement
  };
}
